<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Playbook</title>
  <!-- MathJax for math rendering -->
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        enableMenu: false,
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        ignoreHtmlClass: 'tex2jax_ignore',
        processHtmlClass: 'tex2jax_process'
      },
      chtml: {
        displayAlign: 'left',
        displayIndent: '0'
      },
      svg: {
        displayAlign: 'left',
        displayIndent: '0'
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked@12.0.0/marked.min.js"></script>
  <style>
    :root { --bg:#f6f7fb; --card:#ffffff; --ink:#0f172a; --muted:#6b7280; --accent:#111827; --ring:#e5e7eb; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; color: var(--ink); background: linear-gradient(135deg,#f8fafc,#e5e7eb); }
    .wrap { max-width: 100%; margin: 0; padding: 12px 16px; }
    .row { display: grid; grid-template-columns: 1.2fr .8fr .8fr; gap: 12px; }
    .row-1 { display: grid; grid-template-columns: 1fr; gap: 12px; }
    .card { background: var(--card); border: 1px solid var(--ring); border-radius: 8px; padding: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.03); }
    .title { font-weight: 800; font-size: 22px; letter-spacing: -0.2px; }
    label { display:block; font-size:12px; color: var(--muted); margin-bottom:6px; }
    input[type="text"], input[type="number"], input[type="password"], select { width:100%; padding:10px 12px; border:1px solid var(--ring); border-radius:12px; outline:none; }
    input[type="range"]{ width:100%; }
    .muted{ color: var(--muted); }
    .btn { appearance:none; border:0; background: var(--accent); color:#fff; padding:10px 14px; border-radius: 999px; cursor:pointer; font-weight:600; }
    .btn:disabled { opacity:.6; cursor:not-allowed; }
    .btn-ghost { background: #fff; color: var(--ink); border:1px solid var(--ring); }
    .toolbar { display:flex; gap:8px; align-items:center; }
    .grid { display:grid; gap:16px; }
    .tree { display:grid; gap:10px; }
    .node { padding:10px 12px; border-radius:14px; border:1px solid var(--ring); background:#fff; }
    .node-head { display:flex; gap:8px; align-items:flex-start; cursor:pointer; }
    .node-title-row { display:flex; align-items:center; gap:8px; }
    .chev { display:inline-block; transition: transform .2s; font-size:12px; }
    .id { font-size:11px; color:var(--muted); }
    .desc { font-size:13px; color:var(--muted); margin-top:4px; }
    .children { border-left:2px solid var(--ring); margin-left:12px; padding-left:12px; display:grid; gap:8px; margin-top:8px; }
    .pill { display:inline-flex; align-items:center; gap:6px; border:1px solid var(--ring); border-radius:999px; padding:6px 10px; background:#fff; font-size:12px; color:var(--muted); }
    .flex { display:flex; gap:10px; align-items:center; }
    .space { height: 6px; }
    .right { margin-left:auto; }
    .danger { color:#b91c1c; }
    .ok { color:#065f46; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .footer { color:var(--muted); font-size:12px; }
    .readbox { margin-top:8px; background:#fafafa; border:1px solid var(--ring); border-radius:12px; padding:10px; }
    .readbox .MathJax { font-size: 1.1em; user-select: text; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text; }
    .readbox .MathJax_Display { margin: 0.5em 0; user-select: text; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text; }
    .readbox h1, .readbox h2, .readbox h3, .readbox h4, .readbox h5, .readbox h6 { margin: 0.5em 0 0.3em 0; font-weight: 600; }
    .readbox h1 { font-size: 1.3em; }
    .readbox h2 { font-size: 1.2em; }
    .readbox h3 { font-size: 1.1em; }
    .readbox p { margin: 0.5em 0; line-height: 1.5; }
    .readbox ul, .readbox ol { margin: 0.5em 0; padding-left: 1.5em; }
    .readbox li { margin: 0.2em 0; }
    .readbox code { background: #f0f0f0; padding: 0.2em 0.4em; border-radius: 3px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 0.9em; }
    .readbox pre { background: #f0f0f0; padding: 0.8em; border-radius: 6px; overflow-x: auto; margin: 0.5em 0; }
    .readbox pre code { background: none; padding: 0; }
    .readbox blockquote { border-left: 3px solid var(--ring); padding-left: 1em; margin: 0.5em 0; color: var(--muted); }
    .readbox strong { font-weight: 600; }
    .readbox em { font-style: italic; }
    .chat-container { margin-top:12px; border:1px solid var(--ring); border-radius:12px; background:#fff; }
    .chat-header { padding:8px 12px; background:#f8f9fa; border-bottom:1px solid var(--ring); border-radius:12px 12px 0 0; font-size:12px; font-weight:600; color:var(--muted); }
    .chat-messages { max-height:300px; overflow-y:auto; padding:8px; }
    .chat-message { margin-bottom:8px; padding:8px 12px; border-radius:12px; font-size:13px; line-height:1.4; }
    .chat-message.user { background:#e3f2fd; margin-left:20px; }
    .chat-message.assistant { background:#f5f5f5; margin-right:20px; }
    .chat-message h1, .chat-message h2, .chat-message h3, .chat-message h4, .chat-message h5, .chat-message h6 { margin: 0.3em 0 0.2em 0; font-weight: 600; }
    .chat-message h1 { font-size: 1.2em; }
    .chat-message h2 { font-size: 1.1em; }
    .chat-message h3 { font-size: 1.05em; }
    .chat-message p { margin: 0.3em 0; line-height: 1.4; }
    .chat-message ul, .chat-message ol { margin: 0.3em 0; padding-left: 1.2em; }
    .chat-message li { margin: 0.1em 0; }
    .chat-message code { background: #e0e0e0; padding: 0.1em 0.3em; border-radius: 2px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 0.85em; }
    .chat-message pre { background: #e0e0e0; padding: 0.5em; border-radius: 4px; overflow-x: auto; margin: 0.3em 0; }
    .chat-message pre code { background: none; padding: 0; }
    .chat-message blockquote { border-left: 2px solid #ccc; padding-left: 0.8em; margin: 0.3em 0; color: var(--muted); }
    .chat-message strong { font-weight: 600; }
    .chat-message em { font-style: italic; }
    .chat-message .MathJax { user-select: text; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text; }
    .chat-message .MathJax_Display { user-select: text; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text; }
    .chat-input-container { display:flex; gap:8px; padding:8px; border-top:1px solid var(--ring); }
    .chat-input { flex:1; padding:8px 12px; border:1px solid var(--ring); border-radius:20px; outline:none; font-size:13px; }
    .chat-send-btn { padding:8px 16px; background:var(--accent); color:#fff; border:none; border-radius:20px; cursor:pointer; font-size:12px; font-weight:600; }
    .chat-send-btn:disabled { opacity:0.6; cursor:not-allowed; }
    .video-container { margin-top:12px; border:1px solid var(--ring); border-radius:12px; background:#fff; }
    .video-header { padding:8px 12px; background:#f8f9fa; border-bottom:1px solid var(--ring); border-radius:12px 12px 0 0; font-size:12px; font-weight:600; color:var(--muted); }
    .video-grid { display:grid; grid-template-columns:repeat(auto-fill, minmax(280px, 1fr)); gap:12px; padding:12px; }
    .video-thumbnail { border:1px solid var(--ring); border-radius:8px; overflow:hidden; background:#fff; transition:transform 0.2s, box-shadow 0.2s; }
    .video-thumbnail:hover { transform:translateY(-2px); box-shadow:0 4px 12px rgba(0,0,0,0.1); }
    .video-thumbnail img { width:100%; height:158px; object-fit:cover; }
    .video-info { padding:8px 12px; }
    .video-title { font-size:13px; font-weight:600; line-height:1.3; margin-bottom:4px; color:var(--ink); display:-webkit-box; -webkit-line-clamp:2; line-clamp:2; -webkit-box-orient:vertical; overflow:hidden; }
    .video-channel { font-size:11px; color:var(--muted); margin-bottom:2px; }
    .video-duration { font-size:11px; color:var(--muted); }
    .readbtn { font-size:12px; padding:4px 8px; border-radius:999px; border:1px solid var(--ring); background:#fff; cursor:pointer; }
    .readbtn[disabled] { opacity:.6; cursor:not-allowed; }
    .selection-toolbar { position:fixed; z-index:1000; background:var(--card); border:1px solid var(--ring); border-radius:12px; padding:8px; box-shadow:0 8px 32px rgba(0,0,0,0.12); display:none; gap:8px; align-items:center; pointer-events:auto; }
    .selection-toolbar button { font-size:12px; padding:6px 12px; border-radius:8px; border:1px solid var(--ring); background:#fff; cursor:pointer; font-weight:500; }
    .selection-toolbar button:hover { background:#f8f9fa; }
    .selection-toolbar button.primary { background:var(--accent); color:#fff; border-color:var(--accent); }
    .selection-toolbar button.primary:hover { background:#0f1419; }
    .deepdive-chip { display:inline-flex; align-items:center; gap:4px; background:#e3f2fd; color:#1565c0; font-size:10px; padding:2px 6px; border-radius:4px; margin-left:8px; }
    .deepdive-chip:hover { background:#bbdefb; }
    .undo-btn { font-size:11px; padding:4px 8px; border-radius:6px; border:1px solid var(--ring); background:#fff; cursor:pointer; color:var(--muted); }
    .undo-btn:hover { background:#f8f9fa; color:var(--ink); }
    .undo-btn:disabled { opacity:0.5; cursor:not-allowed; }
    .levels-toggle { font-size:11px; padding:4px 8px; border-radius:6px; border:1px solid var(--ring); background:#fff; cursor:pointer; color:var(--muted); display:inline-flex; align-items:center; }
    .levels-toggle:hover { background:#f8f9fa; color:var(--ink); }
    .levels-toggle.active { background:#e3f2fd; color:#1565c0; border-color:#1565c0; }
    .levels-toggle input[type="checkbox"] { margin:0; margin-right:4px; }
    .gear-icon { position:absolute; top:20px; right:20px; width:24px; height:24px; cursor:pointer; color:var(--muted); transition:color 0.2s; }
    .gear-icon:hover { color:var(--ink); }
    .visualize-btn { font-size:11px; padding:4px 8px; border-radius:6px; border:1px solid var(--ring); background:#fff; cursor:pointer; color:var(--muted); margin-left:4px; }
    .visualize-btn:hover { background:#f8f9fa; color:var(--ink); }
    .visualize-btn:disabled { opacity:0.5; cursor:not-allowed; }
    .modal { display:none; position:fixed; z-index:1000; left:0; top:0; width:100%; height:100%; background-color:rgba(0,0,0,0.5); }
    .modal-content { background-color:#fff; margin:5% auto; padding:20px; border-radius:12px; width:80%; max-width:800px; max-height:80vh; overflow-y:auto; }
    .modal-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:20px; }
    .modal-title { font-size:18px; font-weight:600; color:var(--ink); }
    .modal-close { font-size:24px; font-weight:bold; cursor:pointer; color:var(--muted); }
    .modal-close:hover { color:var(--ink); }
    .modal-image { width:100%; max-width:100%; height:auto; border-radius:8px; margin-bottom:15px; }
    .modal-loading { text-align:center; padding:40px; color:var(--muted); }
    .modal-caption { font-size:14px; color:var(--ink); text-align:center; margin-top:10px; font-style:italic; }
    .summary-box { background:#f8f9fa; border:1px solid var(--ring); border-radius:8px; padding:12px; margin-bottom:15px; font-size:14px; line-height:1.5; color:var(--ink); }
    
    /* Navigation Mode Styles */
    .nav-mode-leftnav { display: flex; height: calc(100vh - 80px); }
    .nav-mode-inline { display: block; }
    
    .left-nav-sidebar { 
      width: 260px; 
      background: #fff; 
      border-right: 1px solid var(--ring); 
      overflow-y: auto; 
      padding: 0;
      flex-shrink: 0;
      transition: width 0.3s ease;
    }
    
    .left-nav-sidebar.collapsed {
      width: 40px;
    }
    
    .left-nav-header {
      position: relative;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      border-bottom: 1px solid var(--ring);
      background: #f8f9fa;
    }
    
    .left-nav-header .left-nav-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--ink);
    }
    
    .left-nav-toggle-btn {
      position: absolute;
      right: -12px;
      top: 50%;
      transform: translateY(-50%);
      background: #fff;
      border: 1px solid var(--ring);
      border-left: none;
      cursor: pointer;
      padding: 8px 4px;
      border-radius: 0 6px 6px 0;
      color: var(--muted);
      font-size: 12px;
      transition: all 0.2s;
      z-index: 10;
      box-shadow: 2px 0 4px rgba(0,0,0,0.1);
    }
    
    .left-nav-toggle-btn:hover {
      background: var(--ring);
      color: var(--ink);
      box-shadow: 2px 0 6px rgba(0,0,0,0.15);
    }
    
    .left-nav-sidebar.collapsed .left-nav-toggle-btn {
      transform: rotate(180deg);
    }
    
    .left-nav-sidebar.collapsed .left-nav-header .left-nav-title {
      display: none;
    }
    
    .left-nav-sidebar.collapsed .left-nav-tree {
      display: none;
    }
    
    .left-nav-tree {
      padding: 12px;
    }
    
    .main-content-pane { 
      flex: 1; 
      overflow-y: auto; 
      padding: 12px 16px;
      background: var(--bg);
      max-width: none;
    }
    
    .left-nav-tree { list-style: none; padding: 0; margin: 0; }
    .left-nav-tree li { margin: 0; }
    .left-nav-node { 
      display: block; 
      padding: 8px 12px; 
      border-radius: 6px; 
      cursor: pointer; 
      transition: all 0.2s;
      border-left: 3px solid transparent;
      margin-bottom: 2px;
    }
    .left-nav-node:hover { background: #f8f9fa; }
    .left-nav-node.active { 
      background: #e3f2fd; 
      border-left-color: #2196f3; 
      font-weight: 600;
    }
    .left-nav-node.deep-dive { 
      border-left-color: #ff9800; 
      position: relative;
    }
    .left-nav-node.deep-dive::before {
      content: "🔍";
      position: absolute;
      left: -20px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 12px;
    }
    .left-nav-children { 
      margin-left: 20px; 
      margin-top: 4px;
    }
    .left-nav-toggle { 
      display: inline-block; 
      width: 16px; 
      text-align: center; 
      margin-right: 8px;
      cursor: pointer;
    }
    .left-nav-toggle::before { content: "▶"; }
    .left-nav-toggle.expanded::before { content: "▼"; }
    .left-nav-title { font-size: 13px; line-height: 1.4; }
    .left-nav-description { 
      font-size: 11px; 
      color: var(--muted); 
      margin-top: 2px; 
      line-height: 1.3;
    }
    
    @media (max-width: 768px) {
      .left-nav-sidebar { 
        position: fixed; 
        left: -260px; 
        top: 0; 
        height: 100vh; 
        z-index: 1001;
        transition: left 0.3s ease;
      }
      .left-nav-sidebar.open { left: 0; }
      .main-content-pane { margin-left: 0; }
      .wrap { padding: 8px 12px; }
    }
    .settings-panel { position:absolute; top:50px; right:20px; background:#fff; border:1px solid var(--ring); border-radius:8px; padding:16px; box-shadow:0 4px 12px rgba(0,0,0,0.1); z-index:1000; min-width:280px; display:none; }
    .settings-panel.show { display:block; }
    .settings-group { margin-bottom:16px; }
    .settings-group:last-child { margin-bottom:0; }
    .settings-label { font-size:12px; font-weight:600; color:var(--ink); margin-bottom:8px; display:block; }
    .settings-row { display:flex; align-items:center; gap:8px; margin-bottom:8px; }
    .settings-row:last-child { margin-bottom:0; }
    .settings-row label { font-size:11px; color:var(--muted); white-space:nowrap; }
    .settings-row input, .settings-row select { font-size:11px; padding:4px 6px; border:1px solid var(--ring); border-radius:4px; }
    .settings-row input[type="range"] { flex:1; }
    .settings-row .value { font-size:10px; color:var(--muted); min-width:30px; text-align:right; }
    .levels-tabs { display:flex; gap:4px; margin:8px 0; flex-wrap:wrap; }
    .level-tab { font-size:11px; padding:4px 8px; border-radius:4px; border:1px solid var(--ring); background:#fff; cursor:pointer; color:var(--muted); transition:all 0.2s; }
    .level-tab:hover { background:#f8f9fa; color:var(--ink); }
    .level-tab.active { background:var(--accent); color:#fff; border-color:var(--accent); font-weight:600; }
    .level-tab.loading { opacity:0.6; cursor:not-allowed; }
    .level-content { margin-top:8px; background:#fafafa; border:1px solid var(--ring); border-radius:12px; padding:10px; }
    .level-content .MathJax { font-size: 1.1em; user-select: text; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text; }
    .level-content .MathJax_Display { margin: 0.5em 0; user-select: text; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text; }
    .level-content h1, .level-content h2, .level-content h3, .level-content h4, .level-content h5, .level-content h6 { margin: 0.5em 0 0.3em 0; font-weight: 600; }
    .level-content h1 { font-size: 1.3em; }
    .level-content h2 { font-size: 1.2em; }
    .level-content h3 { font-size: 1.1em; }
    .level-content p { margin: 0.5em 0; line-height: 1.5; }
    .level-content ul, .level-content ol { margin: 0.5em 0; padding-left: 1.5em; }
    .level-content li { margin: 0.2em 0; }
    .level-content code { background: #f0f0f0; padding: 0.2em 0.4em; border-radius: 3px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 0.9em; }
    .level-content pre { background: #f0f0f0; padding: 0.8em; border-radius: 6px; overflow-x: auto; margin: 0.5em 0; }
    .level-content pre code { background: none; padding: 0; }
    .level-content blockquote { border-left: 3px solid var(--ring); padding-left: 1em; margin: 0.5em 0; color: var(--muted); }
    .level-content strong { font-weight: 600; }
    .level-content em { font-style: italic; }
    @media (max-width: 980px) { .row { grid-template-columns: 1fr; } }
    
    /* Wide layout optimizations */
    .tree { max-width: none; }
    .readbox { max-width: none; }
    .chat-container { max-width: none; }
    .level-content { max-width: none; }
    
    /* Comfortable reading width option */
    .comfortable-width .readbox,
    .comfortable-width .chat-message,
    .comfortable-width .level-content {
      max-width: 85ch;
      margin: 0 auto;
    }
    
    /* Ensure no internal max-widths constrain content */
    .main-content-pane * {
      max-width: none;
    }
    
    .comfortable-width .main-content-pane .readbox,
    .comfortable-width .main-content-pane .chat-message,
    .comfortable-width .main-content-pane .level-content {
      max-width: 85ch;
      margin: 0 auto;
    }
    
    .content-controls {
      display: flex;
      gap: 16px;
      margin: 12px 0;
      padding: 8px 0;
      border-bottom: 1px solid var(--ring);
    }
    
    .control-checkbox {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      color: var(--ink);
      cursor: pointer;
    }
    
    .control-checkbox input[type="checkbox"] {
      margin: 0;
      cursor: pointer;
    }
    
    .btn.read {
      background: #10b981;
      color: white;
      border-color: #10b981;
    }
    
    .btn.read:hover {
      background: #059669;
      border-color: #059669;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="toolbar" style="justify-content:space-between; margin-bottom: 8px; position:relative; padding: 0 4px;">
      <div class="title" style="position:absolute; left:4px; z-index: 1;">Playbook</div>
      <div class="flex" style="justify-content:center; flex: 1; margin: 0 120px;">
        <input id="inpTopic" type="text" placeholder="e.g., Neural Networks, Ramayana, Corporate Finance" style="margin-right: 8px; padding: 8px 12px; border: 1px solid var(--ring); border-radius: 6px; font-size: 14px; min-width: 300px;" />
        <button id="btnGen" class="btn">Learn</button>
      </div>
      
      <!-- Settings Panel -->
      <div class="gear-icon" onclick="toggleSettings()" title="Settings" style="position:absolute; right:4px; z-index: 1;">
        <svg viewBox="0 0 24 24" fill="currentColor">
          <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.22,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.22,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
        </svg>
    </div>

      <div class="settings-panel" id="settingsPanel">
        <div class="settings-group">
          <label class="settings-label">Content Settings</label>
          <div class="settings-row">
            <label for="inpAudience">Audience:</label>
            <input type="text" id="inpAudience" value="general" placeholder="e.g., high school students..." />
        </div>
          <div class="settings-row">
            <label for="inpDepth">Depth:</label>
            <input type="number" id="inpDepth" min="1" max="6" value="3" style="width:60px;" />
            </div>
          <div class="settings-row">
            <label for="inpSections">Sections:</label>
            <input type="number" id="inpSections" min="2" max="12" value="5" style="width:60px;" />
            </div>
            </div>
        
        <div class="settings-group">
          <label class="settings-label">Navigation</label>
          <div class="settings-row">
            <label>
              <input type="radio" name="navMode" value="leftnav" id="navLeftNav" checked />
              Left Nav
            </label>
          </div>
          <div class="settings-row">
            <label>
              <input type="radio" name="navMode" value="inline" id="navInline" />
              Inline Tree
            </label>
          </div>
        </div>
        
        <div class="settings-group">
          <label class="settings-label">Reading Width</label>
          <div class="settings-row">
            <label>
              <input type="radio" name="readingWidth" value="full" id="readingFull" checked />
              Full Width
            </label>
          </div>
          <div class="settings-row">
            <label>
              <input type="radio" name="readingWidth" value="comfortable" id="readingComfortable" />
              Comfortable
            </label>
          </div>
        </div>
        
        <div class="settings-group">
          <label class="settings-label">Model Settings</label>
          <div class="settings-row">
            <label for="selModel">Model:</label>
              <select id="selModel">
                <option value="gpt-4.1-mini">gpt-4.1-mini</option>
                <option value="gpt-4.1">gpt-4.1</option>
                <option value="gpt-5-mini">gpt-5-mini</option>
              </select>
            </div>
          <div class="settings-row">
            <label for="inpTemp">Temperature:</label>
            <input type="range" id="inpTemp" min="0" max="1" step="0.05" value="0.3" />
            <span class="value" id="tempVal">0.30</span>
          </div>
          <div class="settings-row">
            <label>
              <input type="checkbox" id="chkLive" checked />
              Use Live API
            </label>
        </div>
      </div>

        <div class="settings-group">
          <label class="settings-label">Actions</label>
          <div class="settings-row">
            <button id="btnCopy" onclick="copyJSON()">Copy JSON</button>
            <button id="btnSave" onclick="saveNotebook()">Save Notebook</button>
        </div>
          <div class="settings-row">
            <button id="btnOpen" onclick="openNotebook()">Open Notebook</button>
            <button id="btnUndo" onclick="undoLastChange()" disabled>Undo</button>
        </div>
        </div>
      </div>
    </div>

    <!-- Error Display -->
    <div id="errorBox" class="muted danger" style="margin: 12px 0; padding: 8px 12px; background: #fef2f2; border: 1px solid #fecaca; border-radius: 6px; color: #dc2626; display: none;"></div>

    <div class="space"></div>

    <!-- Result -->
    <div class="card" style="padding: 8px 12px;">
      <div class="toolbar" style="justify-content:space-between; margin-bottom: 8px;">
        <div>
          <div class="muted">Result</div>
          <div id="resultTitle" style="font-weight:700; font-size:18px;">No topic yet</div>
        </div>
        <div class="muted">Top-level sections: <span id="topCount">0</span></div>
      </div>

      <!-- Breadcrumb -->
      <div id="breadcrumb" class="muted mono" style="margin-top:4px; overflow:auto; white-space:nowrap;"></div>

      <!-- Navigation Container -->
      <div id="navContainer" class="nav-mode-leftnav">
        <!-- Left Navigation Sidebar -->
        <div id="leftNavSidebar" class="left-nav-sidebar">
          <div class="left-nav-header">
            <span class="left-nav-title">Navigation</span>
            <button id="leftNavToggle" class="left-nav-toggle-btn" title="Collapse/Expand">◀</button>
          </div>
          <div id="leftNavTree" class="left-nav-tree"></div>
        </div>
        
        <!-- Main Content Pane -->
        <div id="mainContentPane" class="main-content-pane">
      <div id="tree" class="tree" style="margin-top:10px;"></div>
        </div>
      </div>
    </div>

    <div class="space"></div>

    <div class="footer">Tip: Click a section, Read button, or Suggest videos button. Expansions call the LLM again with your current settings and keep ancestors expanded. After reading content, use the chat feature to ask questions about specific items. Select text in read content and use Ctrl+D to dive deeper.</div>
  </div>

  <!-- Selection Toolbar -->
  <div id="selectionToolbar" class="selection-toolbar">
    <button id="btnDiveDeep" class="primary">Dive Deep</button>
    <button id="btnCopySelection">Copy</button>
    <button id="btnAskAboutSelection">Ask Chat</button>
  </div>

  <!-- Visualization Modal -->
  <div id="visualizationModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Visualization</div>
        <span class="modal-close" onclick="closeVisualizationModal()">&times;</span>
      </div>
      <div id="modalBody">
        <div class="modal-loading">Generating visualization...</div>
      </div>
    </div>
  </div>

  <script>
    // ----------------------- Utilities -----------------------
    const $ = (id) => document.getElementById(id);
    const slug = (s) => (s||"")
      .toLowerCase().trim()
      .replace(/[^a-z0-9\s/\-]/g, "")
      .replace(/\s+/g, "-")
      .replace(/-+/g, "-");
    const blobDownload = (filename, text, type="application/json") => {
      const a = document.createElement("a");
      a.href = URL.createObjectURL(new Blob([text], { type }));
      a.download = filename; document.body.appendChild(a); a.click(); a.remove();
    };

    // Configure marked for Markdown rendering
    if (typeof marked !== 'undefined') {
      marked.setOptions({
        breaks: true,
        gfm: true,
        sanitize: false, // We trust our content
        smartLists: true,
        smartypants: true
      });
    }

    // Normalize math delimiters before rendering
    function normalizeMathDelimiters(text) {
      if (!text) return "";
      
      // Convert "( \ ... )" patterns to \(...\)
      text = text.replace(/\(\s*\\([^)]+)\s*\)/g, '\\($1\\)');
      
      // Convert standalone "[ \n ... \n ]" blocks to $$...$$
      text = text.replace(/\[\s*\n([\s\S]*?)\n\s*\]/g, (match, content) => {
        // Check if content looks like math (contains common LaTeX commands)
        if (/\\[a-zA-Z]+|\\[(){}[\]]|\\frac|\\sum|\\int|\\alpha|\\beta|\\gamma|\\delta|\\epsilon|\\pi|\\sigma|\\tau|\\phi|\\omega/.test(content)) {
          return `$$${content}$$`;
        }
        return match; // Keep original if not math
      });
      
      // Remove code fences that only wrap math
      text = text.replace(/```[\s\S]*?```/g, (match) => {
        const content = match.replace(/```/g, '').trim();
        // If content is mostly math, remove the fences
        if (/\\[a-zA-Z]+|\\[(){}[\]]|\\frac|\\sum|\\int|\\alpha|\\beta|\\gamma|\\delta|\\epsilon|\\pi|\\sigma|\\tau|\\phi|\\omega/.test(content)) {
          return content;
        }
        return match;
      });
      
      // Remove backticks that only wrap math
      text = text.replace(/`([^`]+)`/g, (match, content) => {
        // If content is math, remove the backticks
        if (/\\[a-zA-Z]+|\\[(){}[\]]|\\frac|\\sum|\\int|\\alpha|\\beta|\\gamma|\\delta|\\epsilon|\\pi|\\sigma|\\tau|\\phi|\\omega/.test(content)) {
          return content;
        }
        return match;
      });
      
      return text;
    }

    function renderMarkdown(markdownText) {
      if (typeof marked === 'undefined') {
        // Fallback if marked.js isn't loaded
        return markdownText.replace(/\n/g, '<br>');
      }
      // Normalize math delimiters before parsing
      const normalizedText = normalizeMathDelimiters(markdownText);
      return marked.parse(normalizedText);
    }

    // Robust MathJax typesetting helper: if MathJax isn't loaded yet, queue elements
    // and flush when the MathJax script finishes loading. Use typesetMath(el)
    // with a single Element or an array of Elements. Call with no args to
    // typeset the entire document when ready.
    function typesetMath(el) {
      try {
        // Normalize elements into an array or null
        const els = (typeof el === 'undefined' || el === null)
          ? null
          : (Array.isArray(el) ? el : [el]);

        if (window.MathJax && typeof window.MathJax.typesetPromise === 'function') {
          const promise = els ? 
            window.MathJax.typesetPromise(els).catch((err) => console.log('MathJax typeset error:', err)) :
            window.MathJax.typesetPromise().catch((err) => console.log('MathJax typeset error:', err));
          
          // After typesetting, make math elements selectable
          promise.then(() => makeMathSelectable(els));
          return promise;
        }

        // Queue the request for later. Use a global queue array on window.
        window._mj_queue = window._mj_queue || [];
        window._mj_queue.push(els);
        return Promise.resolve();
      } catch (err) {
        console.log('typesetMath failed:', err);
        return Promise.resolve();
      }
    }

    // Make MathJax elements selectable by adding click handlers and visual cues
    function makeMathSelectable(els) {
      if (!els) {
        els = document.querySelectorAll('.MathJax, .MathJax_Display');
      } else if (!Array.isArray(els)) {
        els = [els];
      }

      els.forEach(el => {
        if (!el) return;
        
        // Find all MathJax elements within this container
        const mathElements = el.querySelectorAll('.MathJax, .MathJax_Display');
        mathElements.forEach(mathEl => {
          // Add visual cue that math is selectable
          mathEl.style.cursor = 'text';
          mathEl.style.userSelect = 'text';
          mathEl.style.webkitUserSelect = 'text';
          mathEl.style.mozUserSelect = 'text';
          mathEl.style.msUserSelect = 'text';
          
          // Add title with LaTeX source if available
          const mathNode = mathEl.querySelector('script[type="math/tex"], script[type="math/tex; mode=display"]');
          if (mathNode) {
            mathEl.title = `LaTeX: ${mathNode.textContent}`;
          }
          
          // Add click handler to select the LaTeX source
          mathEl.addEventListener('click', (e) => {
            e.stopPropagation();
            if (mathNode) {
              // Try to select the LaTeX text
              const range = document.createRange();
              range.selectNodeContents(mathNode);
              const selection = window.getSelection();
              selection.removeAllRanges();
              selection.addRange(range);
            }
          });
        });
      });
    }

    // When MathJax script finishes loading, flush any queued typeset requests.
    (function flushMathJaxQueueOnLoad() {
      const script = document.getElementById('MathJax-script');
      if (!script) return;
      script.addEventListener('load', () => {
        if (window.MathJax && typeof window.MathJax.typesetPromise === 'function') {
          const q = window._mj_queue || [];
          for (const els of q) {
            try {
              const promise = els ? 
                window.MathJax.typesetPromise(els).catch((e) => console.log('MathJax typeset error:', e)) :
                window.MathJax.typesetPromise().catch((e) => console.log('MathJax typeset error:', e));
              promise.then(() => makeMathSelectable(els));
            } catch (e) {
              console.log('Error flushing MathJax queue:', e);
            }
          }
          window._mj_queue = [];
        }
      });
    })();

    const SYSTEM_PROMPT =
      "You are an expert curriculum designer and information architect. Given a Topic and constraints, produce a clean, hierarchical table of contents. Focus on clarity, progressive depth, and coverage of the domain. Avoid fluff, keep titles concise, and add 1-sentence descriptions only when valuable.";

    const promptTemplate = ({ topic, audience, depth, sections }) => `
Topic: ${topic}
Audience: ${audience || 'general'}
Desired depth/levels: ${depth ?? 3}
Target sections per level (approx): ${sections ?? 5}

Requirements:
- Return ONLY valid JSON matching the schema { toc: TocNode[] }.
- Each TocNode: { id: string (slug), title: string, description?: string, children?: TocNode[] }
- IDs must be unique, URL-safe slugs derived from titles (e.g., "neural-networks/activation-functions").
- The tree should be reasonably balanced and non-redundant.
- Include foundational -> intermediate -> advanced progression.
- Prefer 3–7 top-level sections unless topic is very narrow.
`;

    const example = { toc: [
      { id: "intro", title: "Introduction", description: "What this topic covers and how to navigate the material.", children:[
        { id: "basics/what-why", title: "What & Why" },
        { id: "basics/terminology", title: "Key Terminology" }
      ]},
      { id: "foundations", title: "Foundations", children:[
        { id: "foundations/concepts", title: "Core Concepts" },
        { id: "foundations/math", title: "Math & Intuition" },
        { id: "foundations/tools", title: "Tooling & Setup" }
      ]},
      { id: "intermediate", title: "Intermediate", children:[
        { id: "intermediate/patterns", title: "Common Patterns" },
        { id: "intermediate/pitfalls", title: "Pitfalls & Anti-Patterns" }
      ]},
      { id: "advanced", title: "Advanced", children:[
        { id: "advanced/state-of-the-art", title: "State of the Art" },
        { id: "advanced/research-frontiers", title: "Research Frontiers" }
      ]}
    ]};

    // ----------------------- State -----------------------
    let RUNS = 0;
    let LIVE = true;  // server-backed by default
  // File save state: lastFileHandle is kept in-memory for this session (allows overwrite when using
  // the File System Access API). lastSavedFileName persists across sessions to suggest a name.
  let lastFileHandle = null;
  let lastSavedFileName = localStorage.getItem('lastSavedNotebookName') || null;
    let CURRENT_TOC = [];
    let BREAD = [];                 // [{id,title}, ...]
    const EXP_CACHE = new Map();    // nodeId -> children[]
    const EXPANDED = new Set();     // nodeId -> expanded?
    const CONTENT = new Map();      // nodeId -> explanation text
    const READING = new Set();      // nodeId -> in-flight read
    const CHAT_HISTORY = new Map(); // nodeId -> [{role: 'user'|'assistant', content: string, ts: string}]
    const CHATTING = new Set();     // nodeId -> in-flight chat
    const VIDEOS = new Map();       // nodeId -> [{title, channel, duration, thumbnail, url}]
    const FETCHING_VIDEOS = new Set(); // nodeId -> in-flight video fetch
    const RUNS_HISTORY = [];        // [{ts, model, temperature, tokens, requestSummary}]
    const DEEP_DIVES = [];          // [{nodeId, selection: {text, snippet, offsets}, createdAt, newChildIds}]
    const DEEP_WITH_CONTEXT = new Set(); // nodeId -> whether deep-dive should include parent/context
    const UNDO_STACK = [];          // [{type, parentId, childrenIds, timestamp}]
    const LEVELS_ENABLED = new Set(); // nodeId → whether Levels UI is enabled
    const ACTIVE_LEVEL = new Map();   // nodeId → active level (1-10)
    const LEVEL_CONTENT = new Map();  // nodeId → Map<level, content>
    const LEVEL_READING = new Set();  // nodeId@level → in-flight read
    const SUMMARIES = new Map();       // nodeId → summary text
    const VISUALIZING = new Set();    // nodeId → in-flight visualization
    const VIZ_ELIG = new Map();        // nodeId → { ok: boolean, score: number, rationale: string }
    const VIZ_ELIG_CHECKING = new Set(); // nodeId → in-flight eligibility check
    
    // Navigation Mode State
    let NAV_MODE = 'leftnav'; // 'leftnav' or 'inline'
    let SELECTED_NODE_ID = null; // Currently selected node in left nav mode
    let READING_WIDTH = 'full'; // 'full' or 'comfortable'

    // ----------------------- Notebook Schema -----------------------
    const NOTEBOOK_VERSION = "1.1.0";
    const AUTOSAVE_KEY = "topic_browser_autosave";
    const AUTOSAVE_DEBOUNCE_MS = 2000;
    let autosaveTimeout = null;
    let currentSelection = null;    // {text, nodeId, range, snippet}

    // ----------------------- Notebook Functions -----------------------
    function serializeNotebook() {
      const now = new Date().toISOString();
      const topic = $("inpTopic").value.trim();
      const audience = $("inpAudience").value.trim() || "general";
      const depth = parseInt($("inpDepth").value || "3", 10);
      const sections = parseInt($("inpSections").value || "5", 10);
      const model = $("selModel").value;
      const temperature = parseFloat($("inpTemp").value || "0.3");

      // Convert Maps and Sets to plain objects/arrays for JSON serialization
      const expansions = {};
      for (const [nodeId, children] of EXP_CACHE) {
        expansions[nodeId] = children;
      }

      const content = {};
      for (const [nodeId, text] of CONTENT) {
        content[nodeId] = text;
      }

      const chat = {};
      for (const [nodeId, messages] of CHAT_HISTORY) {
        chat[nodeId] = messages;
      }

      const videos = {};
      for (const [nodeId, videoList] of VIDEOS) {
        videos[nodeId] = videoList;
      }

      // Serialize levels state
      const levelsEnabled = Array.from(LEVELS_ENABLED);
      const activeLevel = {};
      for (const [nodeId, level] of ACTIVE_LEVEL) {
        activeLevel[nodeId] = level;
      }
      const levelContent = {};
      for (const [nodeId, levelMap] of LEVEL_CONTENT) {
        levelContent[nodeId] = {};
        for (const [level, content] of levelMap) {
          levelContent[nodeId][level] = content;
        }
      }

      const summaries = {};
      for (const [nodeId, summary] of SUMMARIES) {
        summaries[nodeId] = summary;
      }

      const vizElig = {};
      for (const [nodeId, eligibility] of VIZ_ELIG) {
        vizElig[nodeId] = eligibility;
      }

      const deepWithContext = Array.from(DEEP_WITH_CONTEXT);

      const notebook = {
        meta: {
          version: NOTEBOOK_VERSION,
          createdAt: now,
          updatedAt: now,
          appVersion: "1.1.0",
          platform: navigator.userAgent,
          topic: topic
        },
        config: {
          topic,
          audience,
          depth,
          sections,
          model,
          temperature
        },
        toc: CURRENT_TOC,
        expanded: Array.from(EXPANDED),
        bread: BREAD,
        expansions,
        content,
        chat,
        videos,
        runs: RUNS_HISTORY,
        deepDives: DEEP_DIVES,
  deepWithContext,
        levelsEnabled,
        activeLevel,
        levelContent,
        summaries,
        vizElig,
        navMode: NAV_MODE,
        selectedNodeId: SELECTED_NODE_ID,
        readingWidth: READING_WIDTH
      };

      return notebook;
    }

    function deserializeNotebook(notebook) {
      // Validate version and migrate if needed
      const version = notebook.meta?.version || "0.0.0";
      if (version !== NOTEBOOK_VERSION) {
        console.warn(`Notebook version ${version} differs from current ${NOTEBOOK_VERSION}`);
        // Future: add migration logic here
      }

      // Apply config to UI
      if (notebook.config) {
        $("inpTopic").value = notebook.config.topic || "";
        $("inpAudience").value = notebook.config.audience || "general";
        $("inpDepth").value = notebook.config.depth || 3;
        $("inpSections").value = notebook.config.sections || 5;
        $("selModel").value = notebook.config.model || "gpt-4.1-mini";
        $("inpTemp").value = notebook.config.temperature || 0.3;
        $("tempVal").textContent = Number(notebook.config.temperature || 0.3).toFixed(2);
      }

      // Restore state
      CURRENT_TOC = notebook.toc || [];
      BREAD = notebook.bread || [];
      RUNS_HISTORY.splice(0, RUNS_HISTORY.length, ...(notebook.runs || []));
      DEEP_DIVES.splice(0, DEEP_DIVES.length, ...(notebook.deepDives || []));
      
      // Restore levels state
      LEVELS_ENABLED.clear();
      if (notebook.levelsEnabled) {
        for (const nodeId of notebook.levelsEnabled) {
          LEVELS_ENABLED.add(nodeId);
        }
      }
      
      ACTIVE_LEVEL.clear();
      if (notebook.activeLevel) {
        for (const [nodeId, level] of Object.entries(notebook.activeLevel)) {
          ACTIVE_LEVEL.set(nodeId, level);
        }
      }
      
      LEVEL_CONTENT.clear();
      if (notebook.levelContent) {
        for (const [nodeId, levelMap] of Object.entries(notebook.levelContent)) {
          const map = new Map();
          for (const [level, content] of Object.entries(levelMap)) {
            map.set(parseInt(level), content);
          }
          LEVEL_CONTENT.set(nodeId, map);
        }
      }
      
      // Restore summaries
      SUMMARIES.clear();
      if (notebook.summaries) {
        for (const [nodeId, summary] of Object.entries(notebook.summaries)) {
          SUMMARIES.set(nodeId, summary);
        }
      }
      
      // Restore visualization eligibility
      VIZ_ELIG.clear();
      if (notebook.vizElig) {
        for (const [nodeId, eligibility] of Object.entries(notebook.vizElig)) {
          VIZ_ELIG.set(nodeId, eligibility);
        }
      }

      // Restore deep-dive context toggles
      DEEP_WITH_CONTEXT.clear();
      if (notebook.deepWithContext) {
        for (const nodeId of notebook.deepWithContext) {
          DEEP_WITH_CONTEXT.add(nodeId);
        }
      }
      
      // Migration: if no levels state but has content, seed Level 5
      if (notebook.version === "1.0.0" || (!notebook.levelsEnabled && notebook.content)) {
        for (const [nodeId, content] of Object.entries(notebook.content || {})) {
          if (content && !LEVEL_CONTENT.has(nodeId)) {
            LEVEL_CONTENT.set(nodeId, new Map());
            LEVEL_CONTENT.get(nodeId).set(5, content);
          }
        }
      }

      // Clear and restore Maps
      EXP_CACHE.clear();
      if (notebook.expansions) {
        for (const [nodeId, children] of Object.entries(notebook.expansions)) {
          EXP_CACHE.set(nodeId, children);
        }
      }

      CONTENT.clear();
      if (notebook.content) {
        for (const [nodeId, text] of Object.entries(notebook.content)) {
          CONTENT.set(nodeId, text);
        }
      }

      CHAT_HISTORY.clear();
      if (notebook.chat) {
        for (const [nodeId, messages] of Object.entries(notebook.chat)) {
          CHAT_HISTORY.set(nodeId, messages);
        }
      }

      VIDEOS.clear();
      if (notebook.videos) {
        for (const [nodeId, videoList] of Object.entries(notebook.videos)) {
          VIDEOS.set(nodeId, videoList);
        }
      }

      // Restore expanded state
      EXPANDED.clear();
      if (notebook.expanded) {
        for (const nodeId of notebook.expanded) {
          EXPANDED.add(nodeId);
        }
      }

      // Update UI counters
      const topCountEl = document.getElementById("topCount");
      if (topCountEl) topCountEl.textContent = CURRENT_TOC.length;
      
      const runCountEl = document.getElementById("runCount");
      if (runCountEl) runCountEl.textContent = RUNS_HISTORY.length;
      
      const resultTitleEl = document.getElementById("resultTitle");
      if (resultTitleEl) resultTitleEl.textContent = notebook.config?.topic ? `TOC for: ${notebook.config.topic}` : "No topic yet";

      // Restore navigation state
      NAV_MODE = notebook.navMode || 'leftnav';
      SELECTED_NODE_ID = notebook.selectedNodeId || null;
      READING_WIDTH = notebook.readingWidth || 'full';
      
      // Update navigation mode UI
      if (NAV_MODE === 'leftnav') {
        $("navLeftNav").checked = true;
        $("navInline").checked = false;
      } else {
        $("navLeftNav").checked = false;
        $("navInline").checked = true;
      }
      
      // Update reading width UI
      if (READING_WIDTH === 'comfortable') {
        $("readingComfortable").checked = true;
        $("readingFull").checked = false;
      } else {
        $("readingComfortable").checked = false;
        $("readingFull").checked = true;
      }
      
      // Set navigation mode and reading width
      setNavigationMode(NAV_MODE);
      setReadingWidth(READING_WIDTH);

      // Re-render everything
      if (NAV_MODE === 'leftnav') {
        renderLeftNavTree();
      } else {
        if (NAV_MODE === 'leftnav') {
          renderLeftNavTree();
        } else {
          if (NAV_MODE === 'leftnav') {
  renderLeftNavTree();
} else {
  renderTree(CURRENT_TOC);
}
        }
      }
      renderBreadcrumb();

      // Re-typeset MathJax after a short delay to ensure DOM is ready
      setTimeout(() => {
        typesetMath();
      }, 200);
    }

    function saveNotebook() {
      try {
        const notebook = serializeNotebook();
        const topic = notebook.config.topic || "topic";
        const filename = `notebook-${slug(topic)}-${new Date().toISOString().slice(0, 10)}.tbnb`;
        const jsonStr = JSON.stringify(notebook, null, 2);
        blobDownload(filename, jsonStr, "application/json");
      } catch (e) {
        console.error("Failed to save notebook:", e);
        showError(`Failed to save notebook: ${e.message}`);
      }
    }

    function openNotebook() {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".tbnb,.json";
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const notebook = JSON.parse(e.target.result);
            deserializeNotebook(notebook);
            showError("");
          } catch (err) {
            console.error("Failed to load notebook:", err);
            showError(`Failed to load notebook: ${err.message}`);
          }
        };
        reader.readAsText(file);
      };
      input.click();
    }

    function autosave() {
      if (autosaveTimeout) {
        clearTimeout(autosaveTimeout);
      }
      autosaveTimeout = setTimeout(() => {
        try {
          const notebook = serializeNotebook();
          localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(notebook));
        } catch (e) {
          console.warn("Autosave failed:", e);
        }
      }, AUTOSAVE_DEBOUNCE_MS);
    }

    function loadAutosave() {
      try {
        const saved = localStorage.getItem(AUTOSAVE_KEY);
        if (saved) {
          const notebook = JSON.parse(saved);
          const savedTime = new Date(notebook.meta?.updatedAt || 0);
          const now = new Date();
          const hoursAgo = (now - savedTime) / (1000 * 60 * 60);
          
          if (hoursAgo < 24) { // Only offer autosave if less than 24 hours old
            const resume = confirm(
              `Found a saved session from ${savedTime.toLocaleString()}.\n\n` +
              `Do you want to resume where you left off?`
            );
            if (resume) {
              deserializeNotebook(notebook);
              return true;
            }
          }
        }
      } catch (e) {
        console.warn("Failed to load autosave:", e);
      }
      return false;
    }

    // ----------------------- Selection & Deep Dive Functions -----------------------
    function getSelectionInfo() {
      const selection = window.getSelection();
      if (!selection || selection.rangeCount === 0 || selection.toString().trim().length === 0) {
        return null;
      }

      const range = selection.getRangeAt(0);
      const text = selection.toString().trim();
      
      // Validate selection length
      if (text.length < 8 || text.length > 3000) {
        return null;
      }

      // Find the containing readbox, chat message, or node
      let container = range.commonAncestorContainer;
      while (container && container.nodeType !== Node.ELEMENT_NODE) {
        container = container.parentNode;
      }
      
      let readbox = container;
      let chatMessage = null;
      
      // Look for readbox first
      while (readbox && !readbox.classList?.contains('readbox')) {
        readbox = readbox.parentNode;
      }
      
      // If no readbox found, look for chat message
      if (!readbox) {
        let tempContainer = container;
        while (tempContainer && !tempContainer.classList?.contains('chat-message')) {
          tempContainer = tempContainer.parentNode;
        }
        if (tempContainer) {
          chatMessage = tempContainer;
        }
      }
      
      if (!readbox && !chatMessage) {
        return null;
      }

      // Find the node ID by looking for the closest node container
      let nodeContainer = readbox || chatMessage;
      while (nodeContainer && !nodeContainer.classList?.contains('node')) {
        nodeContainer = nodeContainer.parentNode;
      }
      
      if (!nodeContainer) {
        return null;
      }

      // Extract node ID from the node container (look for data attribute or parse from structure)
      const nodeId = findNodeIdFromContainer(nodeContainer);
      if (!nodeId) return null;

      // Create snippet for anchor
      const snippet = text.length > 50 ? text.substring(0, 50) + '...' : text;

      return {
        text,
        nodeId,
        range: range.cloneRange(),
        snippet,
        readbox,
        chatMessage,
        nodeContainer,
        isFromChat: !!chatMessage
      };
    }

    function findNodeIdFromContainer(container) {
      // Look for a data attribute first
      if (container.dataset?.nodeId) {
        return container.dataset.nodeId;
      }
      
      // Fallback: look for node ID in the structure
      const idElement = container.querySelector('.id');
      if (idElement) {
        return idElement.textContent.trim();
      }
      
      return null;
    }

    function showSelectionToolbar(selectionInfo) {
      const toolbar = $("selectionToolbar");
      const rect = selectionInfo.range.getBoundingClientRect();
      
      // Get viewport dimensions
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const toolbarWidth = 200; // Approximate toolbar width
      const toolbarHeight = 40; // Approximate toolbar height
      
      // Calculate position relative to viewport
      let left = rect.left + rect.width / 2 - toolbarWidth / 2;
      let top = rect.top - toolbarHeight - 10; // 10px gap above selection
      
      // Ensure toolbar stays within viewport bounds
      if (left < 10) left = 10;
      if (left + toolbarWidth > viewportWidth - 10) {
        left = viewportWidth - toolbarWidth - 10;
      }
      
      // If selection is too high, show toolbar below
      if (top < 10) {
        top = rect.bottom + 10; // 10px gap below selection
      }
      
      // Ensure toolbar doesn't go below viewport
      if (top + toolbarHeight > viewportHeight - 10) {
        top = viewportHeight - toolbarHeight - 10;
      }
      
      // Apply positioning
      toolbar.style.position = 'fixed';
      toolbar.style.left = `${left}px`;
      toolbar.style.top = `${top}px`;
      toolbar.style.display = 'flex';
      
      currentSelection = selectionInfo;
    }

    function hideSelectionToolbar() {
      const toolbar = $("selectionToolbar");
      toolbar.style.display = 'none';
      currentSelection = null;
    }

    function copySelection() {
      if (currentSelection) {
        navigator.clipboard.writeText(currentSelection.text);
        hideSelectionToolbar();
      }
    }

    function askAboutSelection() {
      if (!currentSelection) return;
      
      const nodeId = currentSelection.nodeId;
      const node = findNodeById(CURRENT_TOC, nodeId);
      if (!node) return;

      // Find the chat container for this node
      const nodeContainer = currentSelection.nodeContainer;
      const chatContainer = nodeContainer.querySelector('.chat-container');
      if (!chatContainer) return;

      // Pre-fill the chat input with the selection
      const chatInput = chatContainer.querySelector('.chat-input');
      if (chatInput) {
        // If selection is from a chat message, ask for clarification
        if (currentSelection.isFromChat) {
          chatInput.value = `Can you elaborate on: "${currentSelection.text}"`;
        } else {
          chatInput.value = `Tell me more about: "${currentSelection.text}"`;
        }
        chatInput.focus();
        
        // Trigger the send button
        const chatSendBtn = chatContainer.querySelector('.chat-send-btn');
        if (chatSendBtn && !chatSendBtn.disabled) {
          chatSendBtn.click();
        }
      }
      
      hideSelectionToolbar();
    }

    function findNodeById(nodes, targetId) {
      for (const node of nodes) {
        if (node.id === targetId) return node;
        if (node.children) {
          const found = findNodeById(node.children, targetId);
          if (found) return found;
        }
      }
      return null;
    }

    function getNodePath(nodeId) {
      const path = [];
      function findPath(nodes, targetId, currentPath = []) {
        for (const node of nodes) {
          const newPath = [...currentPath, { id: node.id, title: node.title }];
          if (node.id === targetId) {
            path.push(...newPath);
            return true;
          }
          if (node.children && findPath(node.children, targetId, newPath)) {
            return true;
          }
        }
        return false;
      }
      findPath(CURRENT_TOC, nodeId);
      return path;
    }

    // ----------------------- Navigation Mode Functions -----------------------
    function setNavigationMode(mode) {
      NAV_MODE = mode;
      const navContainer = $("navContainer");
      const leftNavSidebar = $("leftNavSidebar");
      const mainContentPane = $("mainContentPane");
      
      if (mode === 'leftnav') {
        navContainer.className = 'nav-mode-leftnav';
        leftNavSidebar.style.display = 'block';
        mainContentPane.style.display = 'block';
        renderLeftNavTree();
        if (SELECTED_NODE_ID) {
          selectNodeInLeftNav(SELECTED_NODE_ID);
        }
      } else {
        navContainer.className = 'nav-mode-inline';
        leftNavSidebar.style.display = 'none';
        mainContentPane.style.display = 'block';
        if (NAV_MODE === 'leftnav') {
          renderLeftNavTree();
        } else {
          if (NAV_MODE === 'leftnav') {
  renderLeftNavTree();
} else {
  renderTree(CURRENT_TOC);
}
        }
      }
      
      autosave();
    }

    function toggleLeftNav() {
      const leftNavSidebar = $("leftNavSidebar");
      if (leftNavSidebar) {
        leftNavSidebar.classList.toggle('collapsed');
        autosave();
      }
    }

    function setReadingWidth(width) {
      READING_WIDTH = width;
      const body = document.body;
      
      if (width === 'comfortable') {
        body.classList.add('comfortable-width');
      } else {
        body.classList.remove('comfortable-width');
      }
      
      autosave();
    }

    function renderLeftNavTree() {
      const leftNavTree = $("leftNavTree");
      if (!leftNavTree || CURRENT_TOC.length === 0) return;
      
      leftNavTree.innerHTML = '';
      const ul = document.createElement('ul');
      ul.className = 'left-nav-tree';
      
      CURRENT_TOC.forEach(node => {
        const li = createLeftNavNode(node, 0);
        ul.appendChild(li);
      });
      
      leftNavTree.appendChild(ul);
      
      // Auto-select first node if none selected
      if (!SELECTED_NODE_ID && CURRENT_TOC.length > 0) {
        const firstNode = findFirstSelectableNode(CURRENT_TOC);
        if (firstNode) {
          selectNodeInLeftNav(firstNode.id);
        }
      }
    }

    function createLeftNavNode(node, depth) {
      const li = document.createElement('li');
      const hasChildren = node.children && node.children.length > 0;
      const isDeepDive = DEEP_DIVES.some(dd => dd.newChildIds.includes(node.id));
      
      const nodeDiv = document.createElement('div');
      nodeDiv.className = `left-nav-node ${isDeepDive ? 'deep-dive' : ''}`;
      nodeDiv.dataset.nodeId = node.id;
      
      if (hasChildren) {
        const toggle = document.createElement('span');
        toggle.className = 'left-nav-toggle';
        toggle.addEventListener('click', (e) => {
          e.stopPropagation();
          toggleNodeInLeftNav(node.id);
        });
        nodeDiv.appendChild(toggle);
      } else {
        const spacer = document.createElement('span');
        spacer.style.width = '16px';
        spacer.style.display = 'inline-block';
        nodeDiv.appendChild(spacer);
      }
      
      const title = document.createElement('span');
      title.className = 'left-nav-title';
      title.textContent = node.title;
      nodeDiv.appendChild(title);
      
      if (node.description) {
        const desc = document.createElement('div');
        desc.className = 'left-nav-description';
        desc.textContent = node.description;
        nodeDiv.appendChild(desc);
      }
      
      nodeDiv.addEventListener('click', () => {
        selectNodeInLeftNav(node.id);
        if (!hasChildren) {
          // Auto-read content for leaf nodes
          readSection(node, getNodePath(node.id));
        }
      });
      
      li.appendChild(nodeDiv);
      
      if (hasChildren) {
        const childrenUl = document.createElement('ul');
        childrenUl.className = 'left-nav-children';
        childrenUl.style.display = EXPANDED.has(node.id) ? 'block' : 'none';
        
        node.children.forEach(child => {
          const childLi = createLeftNavNode(child, depth + 1);
          childrenUl.appendChild(childLi);
        });
        
        li.appendChild(childrenUl);
      }
      
      return li;
    }

    function toggleNodeInLeftNav(nodeId) {
      const node = findNodeById(CURRENT_TOC, nodeId);
      if (!node || !node.children) return;
      
      if (EXPANDED.has(nodeId)) {
        EXPANDED.delete(nodeId);
      } else {
        EXPANDED.add(nodeId);
      }
      
      renderLeftNavTree();
      autosave();
    }

    function selectNodeInLeftNav(nodeId) {
      SELECTED_NODE_ID = nodeId;
      
      // Update active state in left nav
      document.querySelectorAll('.left-nav-node').forEach(node => {
        node.classList.remove('active');
      });
      
      const activeNode = document.querySelector(`[data-node-id="${nodeId}"]`);
      if (activeNode) {
        activeNode.classList.add('active');
      }
      
      // Render content in main pane
      renderSelectedNodeContent(nodeId);
      autosave();
    }

    function renderSelectedNodeContent(nodeId) {
      const mainContentPane = $("mainContentPane");
      const node = findNodeById(CURRENT_TOC, nodeId);
      if (!node) return;
      
      // Create content container
      const contentDiv = document.createElement('div');
      contentDiv.className = 'selected-node-content';
      
      // Add node title and description
      const header = document.createElement('div');
      header.className = 'node-header';
      header.innerHTML = `
        <h2>${node.title}</h2>
        ${node.description ? `<p class="node-description">${node.description}</p>` : ''}
      `;
      contentDiv.appendChild(header);
      
      // Add control checkboxes
      const controlsDiv = document.createElement('div');
      controlsDiv.className = 'content-controls';
      controlsDiv.innerHTML = `
        <label class="control-checkbox">
          <input type="checkbox" id="levelsToggle-${nodeId}" ${LEVELS_ENABLED.has(nodeId) ? 'checked' : ''}>
          <span>Levels</span>
        </label>
        <label class="control-checkbox">
          <input type="checkbox" id="deepDiveContext-${nodeId}" checked>
          <span>Deep dive with context</span>
        </label>
      `;
      contentDiv.appendChild(controlsDiv);
      
      // Add content if available
      if (CONTENT.has(nodeId)) {
        const readbox = document.createElement('div');
        readbox.className = 'readbox';
        readbox.innerHTML = renderMarkdown(CONTENT.get(nodeId));
        contentDiv.appendChild(readbox);
        typesetMath(readbox);
      } else {
        // Add read button
        const readBtn = document.createElement('button');
        readBtn.textContent = 'Read';
        readBtn.className = 'btn';
        readBtn.addEventListener('click', () => {
          readSection(node, getNodePath(nodeId));
        });
        contentDiv.appendChild(readBtn);
      }
      
      // Add chat interface
      const chatContainer = document.createElement('div');
      chatContainer.className = 'chat-container';
      chatContainer.innerHTML = `
        <div class="chat-header">Ask questions about ${node.title}</div>
        <div class="chat-messages"></div>
        <div class="chat-input-container">
          <input type="text" class="chat-input" placeholder="Ask a question..." />
          <button class="chat-send-btn">Send</button>
        </div>
      `;
      contentDiv.appendChild(chatContainer);
      
      // Clear and populate main content pane
      mainContentPane.innerHTML = '';
      mainContentPane.appendChild(contentDiv);
      
      // Update left nav highlighting
      updateLeftNavHighlighting(nodeId);
      
      // Initialize chat for this node
      initializeChatForNode(nodeId, chatContainer);
    }

    function updateLeftNavHighlighting(nodeId) {
      // Remove active class from all nodes
      const allNodes = document.querySelectorAll('.left-nav-node');
      allNodes.forEach(node => node.classList.remove('active'));
      
      // Add active class to selected node
      const selectedNode = document.querySelector(`[data-node-id="${nodeId}"]`);
      if (selectedNode) {
        selectedNode.classList.add('active');
      }
    }

    function findFirstSelectableNode(nodes) {
      for (const node of nodes) {
        if (!node.children || node.children.length === 0) {
          return node;
        }
        const found = findFirstSelectableNode(node.children);
        if (found) return found;
      }
      return null;
    }

    function initializeChatForNode(nodeId, chatContainer) {
      const chatInput = chatContainer.querySelector('.chat-input');
      const chatSendBtn = chatContainer.querySelector('.chat-send-btn');
      const messagesContainer = chatContainer.querySelector('.chat-messages');

      // Initialize chat history if not exists
      if (!CHAT_HISTORY.has(nodeId)) {
        CHAT_HISTORY.set(nodeId, []);
      }

      // Load existing chat history
      const chatHistory = CHAT_HISTORY.get(nodeId);
      messagesContainer.innerHTML = '';
      chatHistory.forEach(msg => {
        const msgDiv = document.createElement("div");
        msgDiv.className = `chat-message ${msg.role}`;
        if (msg.role === 'assistant') {
          msgDiv.innerHTML = renderMarkdown(msg.content);
        } else {
          msgDiv.textContent = msg.content;
        }
        messagesContainer.appendChild(msgDiv);
      });

      // Chat input handling
      chatInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !chatSendBtn.disabled) {
          e.preventDefault();
          handleChatMessage(nodeId, chatInput, chatSendBtn, messagesContainer);
        }
      });

      chatSendBtn.addEventListener('click', () => {
        handleChatMessage(nodeId, chatInput, chatSendBtn, messagesContainer);
      });

      // Auto-scroll to bottom
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    // ----------------------- Levels Management Functions -----------------------
    function toggleLevels(nodeId) {
      try {
        if (LEVELS_ENABLED.has(nodeId)) {
          // Turn OFF levels
          LEVELS_ENABLED.delete(nodeId);
          
          // Restore Level 5 content to main CONTENT
          const level5Content = LEVEL_CONTENT.get(nodeId)?.get(5) || "";
          CONTENT.set(nodeId, level5Content);
          
          // Clear active level
          ACTIVE_LEVEL.delete(nodeId);
          
        } else {
          // Turn ON levels
          LEVELS_ENABLED.add(nodeId);
          
          // Initialize level content map if not exists
          if (!LEVEL_CONTENT.has(nodeId)) {
            LEVEL_CONTENT.set(nodeId, new Map());
          }
          
          // Seed Level 5 with existing content
          const existingContent = CONTENT.get(nodeId) || "Click 'Read' to load a Level 5 explanation";
          LEVEL_CONTENT.get(nodeId).set(5, existingContent);
          
          // Set active level to 5
          ACTIVE_LEVEL.set(nodeId, 5);
          
          // Clear main content to avoid duplication
          CONTENT.delete(nodeId);
        }
        
        autosave();
        if (NAV_MODE === 'leftnav') {
          renderLeftNavTree();
        } else {
          if (NAV_MODE === 'leftnav') {
  renderLeftNavTree();
} else {
  renderTree(CURRENT_TOC);
}
        }
      } catch (error) {
        console.error("Error toggling levels:", error);
      }
    }

    function switchLevel(nodeId, level) {
      try {
        ACTIVE_LEVEL.set(nodeId, level);
        
        // If content not cached, fetch it
        if (!LEVEL_CONTENT.get(nodeId)?.has(level)) {
          fetchLevelContent(nodeId, level);
        } else {
          // Just re-render
          if (NAV_MODE === 'leftnav') {
          renderLeftNavTree();
        } else {
          if (NAV_MODE === 'leftnav') {
  renderLeftNavTree();
} else {
  renderTree(CURRENT_TOC);
}
        }
        }
      } catch (error) {
        console.error("Error switching level:", error);
      }
    }

    async function fetchLevelContent(nodeId, level) {
      const readingKey = `${nodeId}@${level}`;
      if (LEVEL_READING.has(readingKey)) return;
      
      LEVEL_READING.add(readingKey);
      if (NAV_MODE === 'leftnav') {
  renderLeftNavTree();
} else {
  renderTree(CURRENT_TOC);
} // Update UI to show "Loading..."
      
      try {
        const node = findNodeById(CURRENT_TOC, nodeId);
        if (!node) return;
        
        const path = getNodePath(nodeId);
        const topic = $("inpTopic").value.trim();
        const audience = $("inpAudience").value.trim() || "general";
        const model = $("selModel").value;
        const temperature = parseFloat($("inpTemp").value || "0.3");
        
        const resp = await fetch("/api/read", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ 
            topic, audience, model, temperature, 
            node: { id: node.id, title: node.title }, 
            path, level 
          })
        });
        
        if (!resp.ok) throw new Error(await resp.text());
        const data = await resp.json();
        
        // Store the content
        if (!LEVEL_CONTENT.has(nodeId)) {
          LEVEL_CONTENT.set(nodeId, new Map());
        }
        LEVEL_CONTENT.get(nodeId).set(level, data.content || "No content returned.");
        
        autosave();
      } catch (e) {
        console.error("Failed to fetch level content:", e);
        showError(`Failed to load ${getLevelLabel(level)} content: ${e.message}`);
      } finally {
        LEVEL_READING.delete(readingKey);
        if (NAV_MODE === 'leftnav') {
          renderLeftNavTree();
        } else {
          if (NAV_MODE === 'leftnav') {
  renderLeftNavTree();
} else {
  renderTree(CURRENT_TOC);
}
        }
      }
    }

    function getLevelDescription(level) {
      const descriptions = {
        1: "Beginner - Simple analogies and examples",
        2: "Basic - Core concepts with examples", 
        3: "Introductory - Key ideas and intuition",
        4: "Intermediate - Balanced explanation",
        5: "Standard - Comprehensive overview",
        6: "Advanced - Detailed with some math",
        7: "Expert - Rigorous with derivations",
        8: "Specialist - Formal treatment",
        9: "Research - Cutting-edge concepts",
        10: "Expert-level - Maximum formalism"
      };
      return descriptions[level] || `Level ${level}`;
    }

    function getLevelLabel(level) {
      const labels = {
        1: "Beginner",
        2: "Learner", 
        3: "Student",
        4: "Intermediate",
        5: "Standard",
        6: "Advanced",
        7: "Expert",
        8: "Specialist",
        9: "Researcher",
        10: "Master"
      };
      return labels[level] || `Level ${level}`;
    }

    async function diveDeep() {
      if (!currentSelection) return;
      
      const selectionInfo = currentSelection;
      const nodeId = selectionInfo.nodeId;
      const node = findNodeById(CURRENT_TOC, nodeId);
      if (!node) return;

      // Show confirmation modal
      const confirmed = confirm(
        `Dive deeper into:\n\n"${selectionInfo.snippet}"\n\nThis will create new child sections based on the selected text. Continue?`
      );
      
      if (!confirmed) {
        hideSelectionToolbar();
        return;
      }

      try {
        const topic = $("inpTopic").value.trim();
        const audience = $("inpAudience").value.trim() || "general";
        const model = $("selModel").value;
        const temperature = parseFloat($("inpTemp").value || "0.3");
        const path = getNodePath(nodeId);

        const resp = await fetch("/api/deepdive", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            topic,
            audience,
            model,
            temperature,
            node: { id: node.id, title: node.title },
            path,
            with_context: DEEP_WITH_CONTEXT.has(node.id),
            selection: {
              text: selectionInfo.text,
              sourceNodeId: nodeId,
              snippet: selectionInfo.snippet
            }
          })
        });

        if (!resp.ok) throw new Error(await resp.text());
        const data = await resp.json();
        const shortName = data.shortName;
        const wrapperDescription = data.wrapperDescription;
        const children = data.children || [];

        if (children.length === 0) {
          alert("Couldn't identify subtopics from the selection. Try selecting a more specific concept or phrase.");
          hideSelectionToolbar();
          return;
        }

        // Create wrapper node
        const wrapperId = `${nodeId}/${slug(shortName)}`;
        const wrapper = {
          id: wrapperId,
          title: shortName,
          description: wrapperDescription,
          children: children.map((child, index) => ({
            id: `${wrapperId}/${slug(child.title || `child-${index}`)}`,
            title: child.title,
            description: child.description,
            readContent: child.readContent
          }))
        };

        // Ensure unique wrapper ID
        let finalWrapperId = wrapperId;
        let counter = 2;
        while (node.children?.some(child => child.id === finalWrapperId)) {
          finalWrapperId = `${nodeId}/${slug(shortName)}-${counter}`;
          counter++;
        }
        wrapper.id = finalWrapperId;
        wrapper.children = wrapper.children.map(child => ({
          ...child,
          id: child.id.replace(wrapperId, finalWrapperId)
        }));

        // Create undo snapshot
        const undoSnapshot = {
          type: 'add-children',
          parentId: nodeId,
          childrenIds: [wrapper.id, ...wrapper.children.map(c => c.id)],
          timestamp: new Date().toISOString()
        };
        UNDO_STACK.push(undoSnapshot);
        updateUndoButton();

        // Add wrapper to the node
        if (!node.children) node.children = [];
        node.children.push(wrapper);

        // Update expansion cache
        EXP_CACHE.set(nodeId, node.children);
        EXP_CACHE.set(wrapper.id, wrapper.children);

        // Add to expanded set: parent, wrapper, and first child only
        EXPANDED.add(nodeId);
        EXPANDED.add(wrapper.id);
        if (wrapper.children.length > 0) {
          EXPANDED.add(wrapper.children[0].id);
        }

        // Set content only for the first child (Overview)
        if (wrapper.children.length > 0 && wrapper.children[0].readContent) {
          // Normalize math delimiters in the deep dive content
          const normalizedContent = normalizeMathDelimiters(wrapper.children[0].readContent);
          CONTENT.set(wrapper.children[0].id, normalizedContent);
          
          // Initialize chat history for Overview with system message
          const overviewId = wrapper.children[0].id;
          if (!CHAT_HISTORY.has(overviewId)) {
            CHAT_HISTORY.set(overviewId, []);
          }
          CHAT_HISTORY.get(overviewId).push({
            role: 'system',
            content: `Overview created from selection: "${selectionInfo.snippet}"`,
            ts: new Date().toISOString()
          });
        }

        // Track deep dive event
        DEEP_DIVES.push({
          nodeId,
          wrapperId: wrapper.id,
          shortName,
          overviewChildId: wrapper.children[0]?.id,
          selection: {
            text: selectionInfo.text,
            snippet: selectionInfo.snippet
          },
          createdAt: new Date().toISOString(),
          newChildIds: [wrapper.id, ...wrapper.children.map(c => c.id)]
        });

        // Re-render and scroll to Overview
        if (NAV_MODE === 'leftnav') {
          renderLeftNavTree();
          // Auto-select the new deep dive node
          selectNodeInLeftNav(wrapper.children[0].id);
        } else {
          if (NAV_MODE === 'leftnav') {
          renderLeftNavTree();
        } else {
          if (NAV_MODE === 'leftnav') {
  renderLeftNavTree();
} else {
  renderTree(CURRENT_TOC);
}
        }
        }
        renderBreadcrumb();
        
        // Scroll to the wrapper (deep dive container) first, then to Overview
        setTimeout(() => {
          const wrapperElement = document.querySelector(`[data-node-id="${wrapper.id}"]`);
          if (wrapperElement) {
            // Scroll to the wrapper first
            wrapperElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            
            // Add a brief highlight effect to the wrapper
            wrapperElement.style.transition = 'background-color 0.3s ease';
            wrapperElement.style.backgroundColor = '#e3f2fd';
            setTimeout(() => {
              wrapperElement.style.backgroundColor = '';
            }, 2000);
            
            // Then scroll to the Overview (first child) after a short delay
            setTimeout(() => {
              const overviewChild = document.querySelector(`[data-node-id="${wrapper.children[0]?.id}"]`);
              if (overviewChild) {
                overviewChild.scrollIntoView({ behavior: 'smooth', block: 'center' });
                
                // Add highlight to the overview as well
                overviewChild.style.transition = 'background-color 0.3s ease';
                overviewChild.style.backgroundColor = '#f0f8ff';
                setTimeout(() => {
                  overviewChild.style.backgroundColor = '';
                }, 1500);
              }
            }, 500);
          }
        }, 100);

        autosave();
        hideSelectionToolbar();

      } catch (e) {
        console.error("Deep dive failed:", e);
        showError(`Deep dive failed: ${e.message}`);
        hideSelectionToolbar();
      }
    }

    // ----------------------- Visualization Functions -----------------------
    async function checkVisualizationEligibility(nodeId) {
      if (VIZ_ELIG_CHECKING.has(nodeId) || VIZ_ELIG.has(nodeId)) return;
      
      const node = findNodeById(CURRENT_TOC, nodeId);
      if (!node) return;
      
      // Skip in mock mode
      if (!LIVE) return;
      
      VIZ_ELIG_CHECKING.add(nodeId);
      
      try {
        const topic = $("inpTopic").value.trim();
        const audience = $("inpAudience").value.trim() || "general";
        const model = $("selModel").value;
        const temperature = parseFloat($("inpTemp").value || "0.3");
        
        // Get content if available
        let content = "";
        if (LEVELS_ENABLED.has(nodeId)) {
          const activeLevel = ACTIVE_LEVEL.get(nodeId) || 5;
          content = LEVEL_CONTENT.get(nodeId)?.get(activeLevel) || "";
        } else {
          content = CONTENT.get(nodeId) || "";
        }
        
        const resp = await fetch("/api/visualize/eligibility", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            topic,
            audience,
            model,
            temperature,
            node: { id: node.id, title: node.title, description: node.description },
            content
          })
        });
        
        if (!resp.ok) throw new Error(await resp.text());
        const data = await resp.json();
        
        VIZ_ELIG.set(nodeId, data);
        
        // Re-render to show/hide the visualize button
        if (NAV_MODE === 'leftnav') {
          renderLeftNavTree();
        } else {
          if (NAV_MODE === 'leftnav') {
  renderLeftNavTree();
} else {
  renderTree(CURRENT_TOC);
}
        }
        
      } catch (e) {
        console.error("Eligibility check failed:", e);
        // On error, assume not eligible
        VIZ_ELIG.set(nodeId, { ok: false, score: 0, rationale: "Check failed" });
      } finally {
        VIZ_ELIG_CHECKING.delete(nodeId);
      }
    }

    async function visualizeContent(nodeId) {
      if (VISUALIZING.has(nodeId)) return;
      
      const node = findNodeById(CURRENT_TOC, nodeId);
      if (!node) return;
      
      VISUALIZING.add(nodeId);
      if (NAV_MODE === 'leftnav') {
  renderLeftNavTree();
} else {
  renderTree(CURRENT_TOC);
}
      
      try {
        const topic = $("inpTopic").value.trim();
        const audience = $("inpAudience").value.trim() || "general";
        const model = $("selModel").value;
        const temperature = parseFloat($("inpTemp").value || "0.3");
        const path = getNodePath(nodeId);
        
        // Get content for visualization
        let content = "";
        if (LEVELS_ENABLED.has(nodeId)) {
          const activeLevel = ACTIVE_LEVEL.get(nodeId) || 5;
          content = LEVEL_CONTENT.get(nodeId)?.get(activeLevel) || "";
        } else {
          content = CONTENT.get(nodeId) || "";
        }
        
        if (!content.trim()) {
          showError("No content available to visualize. Please read the content first.");
          return;
        }
        
        // Show modal
        showVisualizationModal(node.title);
        
        const resp = await fetch("/api/visualize", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            topic,
            audience,
            model,
            temperature,
            node: { id: node.id, title: node.title, description: node.description },
            content
          })
        });
        
        if (!resp.ok) throw new Error(await resp.text());
        const data = await resp.json();
        
        console.log("Visualization response:", data);
        
        // Display the generated image with caption
        displayVisualization(data.imageUrl, data.caption);
        
      } catch (e) {
        console.error("Visualization failed:", e);
        showError(`Visualization failed: ${e.message}`);
        closeVisualizationModal();
      } finally {
        VISUALIZING.delete(nodeId);
        if (NAV_MODE === 'leftnav') {
          renderLeftNavTree();
        } else {
          if (NAV_MODE === 'leftnav') {
  renderLeftNavTree();
} else {
  renderTree(CURRENT_TOC);
}
        }
      }
    }
    
    function showVisualizationModal(title) {
      const modal = $("visualizationModal");
      const modalBody = $("modalBody");
      modalBody.innerHTML = '<div class="modal-loading">Generating visualization...</div>';
      modal.style.display = "block";
    }
    
    function displayVisualization(imageUrl, caption) {
      console.log("displayVisualization called with:", { imageUrl, caption });
      const modalBody = $("modalBody");
      modalBody.innerHTML = `
        <img src="${imageUrl}" alt="${caption || 'Visualization'}" class="modal-image" onerror="console.error('Image failed to load:', this.src)">
        ${caption ? `<p class="modal-caption">${caption}</p>` : ''}
      `;
    }
    
    function closeVisualizationModal() {
      const modal = $("visualizationModal");
      modal.style.display = "none";
    }
    
    // ----------------------- Summary Functions -----------------------
    async function generateSummary(nodeId, content) {
      if (SUMMARIES.has(nodeId)) {
        return SUMMARIES.get(nodeId);
      }
      
      try {
        const topic = $("inpTopic").value.trim();
        const audience = $("inpAudience").value.trim() || "general";
        const model = $("selModel").value;
        const temperature = parseFloat($("inpTemp").value || "0.3");
        const path = getNodePath(nodeId);
        
        const resp = await fetch("/api/summary", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            topic,
            audience,
            model,
            temperature,
            node: { id: nodeId, title: findNodeById(CURRENT_TOC, nodeId)?.title || "" },
            path,
            content
          })
        });
        
        if (!resp.ok) throw new Error(await resp.text());
        const data = await resp.json();
        
        SUMMARIES.set(nodeId, data.summary);
        return data.summary;
        
      } catch (e) {
        console.error("Summary generation failed:", e);
        return "Summary generation failed. Please try again.";
      }
    }

    function undoLastChange() {
      if (UNDO_STACK.length === 0) return;
      
      const lastChange = UNDO_STACK.pop();
      
      if (lastChange.type === 'add-children') {
        const node = findNodeById(CURRENT_TOC, lastChange.parentId);
        if (node && node.children) {
          // Remove the children that were added (including wrapper and its children)
          node.children = node.children.filter(child => 
            !lastChange.childrenIds.includes(child.id)
          );
          
          // Update expansion cache
          if (node.children.length === 0) {
            EXP_CACHE.delete(lastChange.parentId);
          } else {
            EXP_CACHE.set(lastChange.parentId, node.children);
          }
          
          // Remove from expanded set and clean up all related state
          lastChange.childrenIds.forEach(childId => {
            EXPANDED.delete(childId);
            CONTENT.delete(childId);
            CHAT_HISTORY.delete(childId);
            VIDEOS.delete(childId);
            EXP_CACHE.delete(childId); // Also remove wrapper's expansion cache
          });
          
          // Remove from deep dives tracking
          DEEP_DIVES.splice(DEEP_DIVES.findIndex(dd => 
            dd.newChildIds.some(id => lastChange.childrenIds.includes(id))
          ), 1);
          
          // Re-render
          if (NAV_MODE === 'leftnav') {
          renderLeftNavTree();
        } else {
          if (NAV_MODE === 'leftnav') {
  renderLeftNavTree();
} else {
  renderTree(CURRENT_TOC);
}
        }
          renderBreadcrumb();
          autosave();
        }
      }
      
      updateUndoButton();
    }

    function updateUndoButton() {
      const undoBtn = $("btnUndo");
      undoBtn.disabled = UNDO_STACK.length === 0;
    }

    // ----------------------- Rendering -----------------------
    function getTreeContainer() {
      if (NAV_MODE === 'leftnav') {
        return $("leftNavTree");
      } else {
        return $("tree");
      }
    }

    function renderTree(nodes, container) {
      // If no container specified, use the appropriate one based on navigation mode
      if (!container) {
        container = getTreeContainer();
      }
      
      if (!container) {
        console.warn("renderTree called with null container and no valid tree container found");
        return;
      }
      
      container.innerHTML = "";
      if (!nodes || !Array.isArray(nodes) || nodes.length === 0) {
        container.innerHTML = '<div class="muted">No sections yet. Generate a TOC to see results.</div>';
        return;
      }
      nodes.forEach((node) => container.appendChild(renderNode(node, 0, [])));
    }

    function renderNode(node, depth, path) {
      const hasChildren = Array.isArray(node.children) && node.children.length > 0;
      const wrap = document.createElement("div");
      wrap.className = "node";
      wrap.dataset.nodeId = node.id;

      const head = document.createElement("div");
      head.className = "node-head";

      const chev = document.createElement("span");
      chev.className = "chev";
      const isOpen = EXPANDED.has(node.id) || (depth === 0 && EXPANDED.size === 0); // auto-open top-level on first render
      if (isOpen) EXPANDED.add(node.id);
      chev.textContent = hasChildren ? "▶" : "●";
      chev.style.transform = hasChildren && isOpen ? "rotate(90deg)" : "rotate(0deg)";

      // Check if this is a deep dive wrapper
      const isDeepDiveWrapper = DEEP_DIVES.some(dd => dd.wrapperId === node.id);

      const txt = document.createElement("div");
      txt.innerHTML =
        `<div class="node-title-row"><span style="font-weight:600">${node.title}</span>
           ${isDeepDiveWrapper ? '<span class="deepdive-chip" title="Created from text selection">Deep Dive</span>' : ''}
           <button class="readbtn" ${READING.has(node.id) ? "disabled": ""} data-read="${node.id}">${READING.has(node.id) ? "Reading…" : "Read"}</button>
           ${CONTENT.has(node.id) || LEVELS_ENABLED.has(node.id) ? `
           <label class="levels-toggle ${LEVELS_ENABLED.has(node.id) ? 'active' : ''}" data-levels="${node.id}">
             <input type="checkbox" ${LEVELS_ENABLED.has(node.id) ? 'checked' : ''} style="margin-right: 4px;">
             Levels
           </label>
           ` : ''}
           <label class="deepdive-context-toggle" style="margin-left:8px; font-size:12px; display:inline-flex; align-items:center;" data-deepcontext="${node.id}">
             <input type="checkbox" ${DEEP_WITH_CONTEXT.has(node.id) ? 'checked' : ''} style="margin-right:6px;">Deep dive with context
           </label>
         </div>` +
        (node.description ? `<div class="desc">${node.description}</div>` : "") +
        `<div class="id">${node.id}</div>`;

      head.appendChild(chev);
      head.appendChild(txt);
      wrap.appendChild(head);

      // READ button (independent of expand/collapse)
      const readBtn = txt.querySelector('button[data-read]');
      if (readBtn) {
        readBtn.addEventListener('click', async (ev) => {
        ev.stopPropagation();
        await readSection(node, path.concat({ id: node.id, title: node.title }));
      });
      }

      // LEVELS checkbox (independent of expand/collapse)
      const levelsToggle = txt.querySelector('label[data-levels]');
      if (levelsToggle) {
        const levelsCheckbox = levelsToggle.querySelector('input[type="checkbox"]');
        if (levelsCheckbox) {
          levelsCheckbox.addEventListener('change', (ev) => {
        ev.stopPropagation();
            toggleLevels(node.id);
          });
        }
        // Also handle clicking the label
        levelsToggle.addEventListener('click', (ev) => {
          ev.stopPropagation();
          // Don't toggle here since the checkbox change event will handle it
        });
      }

      // Deep-dive with context toggle (independent of expand/collapse)
      const deepContextToggle = txt.querySelector('label[data-deepcontext]');
      if (deepContextToggle) {
        const checkbox = deepContextToggle.querySelector('input[type="checkbox"]');
        if (checkbox) {
          checkbox.addEventListener('change', (ev) => {
            ev.stopPropagation();
            if (checkbox.checked) DEEP_WITH_CONTEXT.add(node.id); else DEEP_WITH_CONTEXT.delete(node.id);
            autosave();
          });
        }
        // Prevent clicks on label from toggling expand
        deepContextToggle.addEventListener('click', (ev) => ev.stopPropagation());
      }

      // SUGGEST VIDEOS button (hidden for now)
      // const videosBtn = txt.querySelector('button[data-videos]');
      // if (videosBtn) {
      //   videosBtn.addEventListener('click', async (ev) => {
      //     ev.stopPropagation();
      //     await suggestVideos(node, path.concat({ id: node.id, title: node.title }));
      //   });
      // }

      // Click to toggle expand (and keep state)
      head.addEventListener("click", async () => {
        if (!hasChildren && !EXP_CACHE.has(node.id)) {
          // No children yet—treat as an expand intent: fetch children
          const newPath = path.concat({ id: node.id, title: node.title });
          for (const p of newPath) EXPANDED.add(p.id); // keep all ancestors open
          await handleNodeClick(node, newPath);
          return; // re-render will show children
        }
        if (hasChildren || EXP_CACHE.has(node.id)) {
          if (EXPANDED.has(node.id)) EXPANDED.delete(node.id); else EXPANDED.add(node.id);
          if (NAV_MODE === 'leftnav') {
          renderLeftNavTree();
        } else {
          if (NAV_MODE === 'leftnav') {
  renderLeftNavTree();
} else {
  renderTree(CURRENT_TOC);
}
        }
        }
      });

      // Children container
      if (hasChildren && isOpen) {
        const childrenDiv = document.createElement("div");
        childrenDiv.className = "children";
        node.children.forEach((c) =>
          childrenDiv.appendChild(
            renderNode(c, depth + 1, path.concat({ id: node.id, title: node.title }))
          )
        );
        wrap.appendChild(childrenDiv);
      }

      // Explanation content (if any)
      if (LEVELS_ENABLED.has(node.id)) {
        // Levels mode: show tabs and level content
        const activeLevel = ACTIVE_LEVEL.get(node.id) || 5;
        
        // Create tabs container
        const tabsContainer = document.createElement("div");
        tabsContainer.className = "levels-tabs";
        
        // Create tabs for levels 1-10
        for (let level = 1; level <= 10; level++) {
          const tab = document.createElement("button");
          tab.className = "level-tab";
          if (level === activeLevel) tab.classList.add("active");
          if (LEVEL_READING.has(`${node.id}@${level}`)) tab.classList.add("loading");
          tab.textContent = getLevelLabel(level);
          tab.title = getLevelDescription(level); // Add tooltip with full description
          tab.onclick = () => switchLevel(node.id, level);
          tabsContainer.appendChild(tab);
        }
        wrap.appendChild(tabsContainer);
        
        // Create level content container
        const levelContentDiv = document.createElement("div");
        levelContentDiv.className = "level-content";
        
        const levelContent = LEVEL_CONTENT.get(node.id)?.get(activeLevel);
        if (levelContent) {
          levelContentDiv.innerHTML = renderMarkdown(levelContent);
          // Process math expressions with MathJax
          typesetMath(levelContentDiv);
        } else if (LEVEL_READING.has(`${node.id}@${activeLevel}`)) {
          levelContentDiv.innerHTML = "<p><em>Loading...</em></p>";
        } else {
          levelContentDiv.innerHTML = `<p><em>Click to load ${getLevelLabel(activeLevel)} content</em></p>`;
        }
        
        wrap.appendChild(levelContentDiv);
        
      } else if (CONTENT.has(node.id)) {
        // Single content mode: show summary first, then full content
        const rb = document.createElement("div");
        rb.className = "readbox";
        
        const summary = SUMMARIES.get(node.id);
        const fullContent = CONTENT.get(node.id);
        
        if (summary && fullContent) {
          // Show summary first, then full content
          rb.innerHTML = `
            <div class="summary-box">
              <strong>Summary:</strong><br>
              ${renderMarkdown(summary)}
            </div>
            <div style="margin-top: 15px;">
              <strong>Full Content:</strong><br>
              ${renderMarkdown(fullContent)}
            </div>
          `;
        } else {
          // Fallback to just the content
          rb.innerHTML = renderMarkdown(fullContent);
        }
        
        wrap.appendChild(rb);
        // Process math expressions with MathJax
        typesetMath(rb);
        }

      // Add chat interface (always show for nodes with content or levels enabled)
      if (CONTENT.has(node.id) || LEVELS_ENABLED.has(node.id)) {
        const chatContainer = document.createElement("div");
        chatContainer.className = "chat-container";
        // Create chat header with level information
        const levelInfo = LEVELS_ENABLED.has(node.id) ? ` (${getLevelLabel(ACTIVE_LEVEL.get(node.id) || 5)})` : "";
        chatContainer.innerHTML = `
          <div class="chat-header">Ask questions about "${node.title}"${levelInfo}</div>
          <div class="chat-messages" id="chat-messages-${node.id}"></div>
          <div class="chat-input-container">
            <input type="text" class="chat-input" id="chat-input-${node.id}" placeholder="Ask a question..." />
            <button class="chat-send-btn" id="chat-send-${node.id}" ${CHATTING.has(node.id) ? "disabled" : ""}>${CHATTING.has(node.id) ? "..." : "Send"}</button>
          </div>
        `;
        wrap.appendChild(chatContainer);

        // Initialize chat messages if history exists
        const messagesContainer = chatContainer.querySelector('.chat-messages');
        const chatHistory = CHAT_HISTORY.get(node.id) || [];
        chatHistory.forEach(msg => {
          const msgDiv = document.createElement("div");
          msgDiv.className = `chat-message ${msg.role}`;
          if (msg.role === 'assistant') {
            msgDiv.innerHTML = renderMarkdown(msg.content);
          } else {
            msgDiv.textContent = msg.content;
          }
          messagesContainer.appendChild(msgDiv);
        });
        if (chatHistory.length > 0) {
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
          // Ensure any math in historical messages gets typeset
          typesetMath(messagesContainer);
        }

        // Add chat event listeners
        const chatInput = chatContainer.querySelector('.chat-input');
        const chatSendBtn = chatContainer.querySelector('.chat-send-btn');

        const sendMessage = async () => {
          const question = chatInput.value.trim();
          if (!question || CHATTING.has(node.id)) return;

          await handleChatMessage(node, path, question, chatContainer);
        };

        chatSendBtn.addEventListener('click', sendMessage);
        chatInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') sendMessage();
        });
      }

        // Add video suggestions if they exist
        if (VIDEOS.has(node.id)) {
          const videoContainer = document.createElement("div");
          videoContainer.className = "video-container";
          videoContainer.innerHTML = `
            <div class="video-header">Suggested videos for "${node.title}" ${!LIVE ? "(Demo videos - click to see real YouTube content)" : ""}</div>
            <div class="video-grid" id="video-grid-${node.id}"></div>
          `;
          wrap.appendChild(videoContainer);

          const videoGrid = videoContainer.querySelector('.video-grid');
          const videos = VIDEOS.get(node.id);
          videos.forEach(video => {
            const videoDiv = document.createElement("div");
            videoDiv.className = "video-thumbnail";
            videoDiv.innerHTML = `
              <img src="${video.thumbnail}" alt="${video.title}" loading="lazy" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgwIiBoZWlnaHQ9IjE1OCIgdmlld0JveD0iMCAwIDI4MCAxNTgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIyODAiIGhlaWdodD0iMTU4IiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0xMjAgNjBMMTYwIDEwMEwxMjAgMTQwTDgwIDEwMEwxMjAgNjBaIiBmaWxsPSIjQ0NDQ0NDIi8+Cjx0ZXh0IHg9IjE0MCIgeT0iMTMwIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMTIiIGZpbGw9IiM5OTk5OTkiPk5vIFRodW1ibmFpbDwvdGV4dD4KPC9zdmc+'" />
              <div class="video-info">
                <div class="video-title">${video.title}</div>
                <div class="video-channel">${video.channel}</div>
                <div class="video-duration">${video.duration}</div>
              </div>
            `;
            videoDiv.addEventListener('click', () => {
              window.open(video.url, '_blank');
            });
            videoGrid.appendChild(videoDiv);
          });
      }

      return wrap;
    }

    // ----------------------- Chat Functionality -----------------------
    async function handleChatMessage(node, path, question, chatContainer) {
      if (CHATTING.has(node.id)) return;
      CHATTING.add(node.id);

      const chatInput = chatContainer.querySelector('.chat-input');
      const chatSendBtn = chatContainer.querySelector('.chat-send-btn');
      const messagesContainer = chatContainer.querySelector('.chat-messages');

      chatInput.value = '';
      chatSendBtn.disabled = true; chatSendBtn.textContent = '...';

      // UI + history (user)
      const userMsgDiv = document.createElement("div");
      userMsgDiv.className = "chat-message user";
      userMsgDiv.textContent = question;
      messagesContainer.appendChild(userMsgDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      if (!CHAT_HISTORY.has(node.id)) CHAT_HISTORY.set(node.id, []);
      CHAT_HISTORY.get(node.id).push({ role: 'user', content: question, ts: new Date().toISOString() });

      try {
        let answer;
        if (!LIVE) {
          answer = `*(mock)* Answer about "${node.title}" → ${question}`;
        } else {
          const topic = $("inpTopic").value.trim();
          const audience = $("inpAudience").value.trim() || "general";
          const model = $("selModel").value;
          const temperature = parseFloat($("inpTemp").value || "0.3");
          const history = CHAT_HISTORY.get(node.id) || [];
          // Use level-specific content if levels are enabled, otherwise use regular content
          let context = "(no content)";
          if (LEVELS_ENABLED.has(node.id)) {
            const activeLevel = ACTIVE_LEVEL.get(node.id) || 5;
            context = LEVEL_CONTENT.get(node.id)?.get(activeLevel) || `${getLevelLabel(activeLevel)} explanation not loaded`;
          } else {
            context = CONTENT.get(node.id) || "(no content)";
          }

          // Include level information in chat request
          const level = LEVELS_ENABLED.has(node.id) ? (ACTIVE_LEVEL.get(node.id) || 5) : null;
          
          const resp = await fetch("/api/chat", {
              method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ topic, audience, model, temperature, node: { id: node.id, title: node.title }, path, question, context, history, level })
          });
          if (!resp.ok) throw new Error(await resp.text());
            const data = await resp.json();
          answer = data.answer || "No answer.";
        }

        const assistantMsgDiv = document.createElement("div");
        assistantMsgDiv.className = "chat-message assistant";
        assistantMsgDiv.innerHTML = renderMarkdown(answer);
        messagesContainer.appendChild(assistantMsgDiv);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        CHAT_HISTORY.get(node.id).push({ role: 'assistant', content: answer, ts: new Date().toISOString() });

        typesetMath(assistantMsgDiv);
        
        autosave();
      } catch (e) {
        const errorMsgDiv = document.createElement("div");
        errorMsgDiv.className = "chat-message assistant";
        errorMsgDiv.textContent = `Error: ${e.message || String(e)}`;
        messagesContainer.appendChild(errorMsgDiv);
      } finally {
        CHATTING.delete(node.id);
        chatSendBtn.disabled = false; chatSendBtn.textContent = 'Send';
        chatInput.focus();
      }
    }

    // ----------------------- Video Suggestions -----------------------
    async function suggestVideos(node, path) {
      if (FETCHING_VIDEOS.has(node.id)) return;
      FETCHING_VIDEOS.add(node.id);
      if (NAV_MODE === 'leftnav') {
        renderLeftNavTree();
        } else {
        renderTree(CURRENT_TOC);
      }

      try {
          const topic = $("inpTopic").value.trim();
        const q = encodeURIComponent(`${node.title} ${topic}`.trim());
        const resp = await fetch(`/api/videos?q=${q}`);
        if (!resp.ok) throw new Error(await resp.text());
          const data = await resp.json();
        VIDEOS.set(node.id, data.videos || []);
        autosave();
      } catch (e) {
        showError(e.message || String(e));
      } finally {
        FETCHING_VIDEOS.delete(node.id);
        if (NAV_MODE === 'leftnav') {
          renderLeftNavTree();
        } else {
          if (NAV_MODE === 'leftnav') {
  renderLeftNavTree();
} else {
  renderTree(CURRENT_TOC);
}
        }
      }
    }

    // ----------------------- Breadcrumb + Expansion + Read -----------------------
    function renderBreadcrumb() {
      const bc = $("breadcrumb");
      if (!BREAD.length) { bc.textContent = ""; return; }
      bc.innerHTML = BREAD.map((p, i) => `${i ? " / " : ""}<strong>${p.title}</strong>`).join("");
    }

    function injectChildren(nodeId, children, ancestorPath = []) {
      function visit(nodes) {
        for (const n of nodes) {
          if (n.id === nodeId) {
            n.children = children;
            EXP_CACHE.set(nodeId, children);
            EXPANDED.add(nodeId);
            for (const a of ancestorPath) EXPANDED.add(a.id); // keep ancestors open
            return true;
          }
          if (n.children && visit(n.children)) return true;
        }
        return false;
      }
      visit(CURRENT_TOC);
      const topCountEl = document.getElementById("topCount");
      if (topCountEl) topCountEl.textContent = CURRENT_TOC.length;
      if (NAV_MODE === 'leftnav') {
  renderLeftNavTree();
} else {
  renderTree(CURRENT_TOC);
}
      renderBreadcrumb();
    }

    async function handleNodeClick(node, path) {
      BREAD = path;
      for (const p of path) EXPANDED.add(p.id); // ensure all open
      renderBreadcrumb();

      // already expanded?
      if (EXP_CACHE.has(node.id)) {
        EXPANDED.add(node.id);
        if (NAV_MODE === 'leftnav') {
          renderLeftNavTree();
        } else {
          if (NAV_MODE === 'leftnav') {
  renderLeftNavTree();
} else {
  renderTree(CURRENT_TOC);
}
        }
        return;
      }

      if (LIVE) {
        try {
          await expandSection(node, path);
        } catch (e) {
          console.warn("Expansion failed:", e);
          showError(e.message || String(e));
        }
      } else {
        // Mock expansion when no children yet
        if (!node.children || node.children.length === 0) {
          const base = slug(node.title || node.id);
          const kids = ["Overview", "Key Ideas", "Deep Dive"].map((t, i) => ({
            id: `${node.id}/${base}-${i + 1}`,
            title: `${t} — ${node.title}`,
          }));
          injectChildren(node.id, kids, path.slice(0, -1));
          autosave();
        }
      }
    }

    async function expandSection(node, path) {
      const topic = $("inpTopic").value.trim();
      const audience = $("inpAudience").value.trim() || "general";
      const depth = parseInt($("inpDepth").value || "3", 10);
      const sections = parseInt($("inpSections").value || "5", 10);
      const model = $("selModel").value;
      const temperature = parseFloat($("inpTemp").value || "0.3");

      const resp = await fetch("/api/expand", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ topic, audience, depth, sections, model, temperature, node: { id: node.id, title: node.title }, path })
      });
      if (!resp.ok) throw new Error(await resp.text());
      const data = await resp.json();
      const kids = data.children || [];
      injectChildren(node.id, kids, path.slice(0, -1));
      autosave();
    }

    async function readSection(node, path) {
      for (const p of path) EXPANDED.add(p.id);

      if (!LIVE) {
        // keep your mock as-is
        const mock = `Summary of "${node.title}":\n• ...\n\n$$\\int_0^1 x^2 dx = 1/3$$`;
        if (LEVELS_ENABLED.has(node.id)) {
          // In levels mode, add to level 5
          if (!LEVEL_CONTENT.has(node.id)) {
            LEVEL_CONTENT.set(node.id, new Map());
          }
          LEVEL_CONTENT.get(node.id).set(5, mock);
        } else {
        CONTENT.set(node.id, mock);
        }
        if (NAV_MODE === 'leftnav') {
          // In left nav mode, just update the selected node content
          if (SELECTED_NODE_ID === node.id) {
            renderSelectedNodeContent(node.id);
          }
        } else {
          if (NAV_MODE === 'leftnav') {
          renderLeftNavTree();
        } else {
          if (NAV_MODE === 'leftnav') {
  renderLeftNavTree();
} else {
  renderTree(CURRENT_TOC);
}
        }
        }
        renderBreadcrumb();
        autosave();
        return;
      }

      // If levels are enabled, refresh the current active level
      if (LEVELS_ENABLED.has(node.id)) {
        const activeLevel = ACTIVE_LEVEL.get(node.id) || 5;
        await fetchLevelContent(node.id, activeLevel);
        return;
      }

      // Regular single content mode
      if (READING.has(node.id)) return;
      READING.add(node.id);
      if (NAV_MODE === 'inline') {
        renderTree(CURRENT_TOC);
      }

      const topic = $("inpTopic").value.trim();
      const audience = $("inpAudience").value.trim() || "general";
      const depth = parseInt($("inpDepth").value || "3", 10);
      const sections = parseInt($("inpSections").value || "5", 10);
      const model = $("selModel").value;
      const temperature = parseFloat($("inpTemp").value || "0.3");

      try {
        const resp = await fetch("/api/read", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ topic, audience, depth, sections, model, temperature, node: { id: node.id, title: node.title }, path })
        });
        if (!resp.ok) throw new Error(await resp.text());
        const data = await resp.json();
        const fullContent = data.content || "No content returned.";
        
        // Generate summary first
        const summary = await generateSummary(node.id, fullContent);
        
        // Store both summary and full content
        CONTENT.set(node.id, fullContent);
        SUMMARIES.set(node.id, summary);
        
        // Check visualization eligibility
        checkVisualizationEligibility(node.id);
        
        autosave();
      } catch (e) {
        showError(e.message || String(e));
      } finally {
        READING.delete(node.id);
        if (NAV_MODE === 'leftnav') {
          // In left nav mode, just update the selected node content
          if (SELECTED_NODE_ID === node.id) {
            renderSelectedNodeContent(node.id);
          }
        } else {
          if (NAV_MODE === 'leftnav') {
          renderLeftNavTree();
        } else {
          if (NAV_MODE === 'leftnav') {
  renderLeftNavTree();
} else {
  renderTree(CURRENT_TOC);
}
        }
        }
        renderBreadcrumb();
      }
    }

    // ----------------------- Generate / Export -----------------------
    async function generate() {
      const topic = $("inpTopic").value.trim();
      const audience = $("inpAudience").value.trim() || "general";
      const depth = parseInt($("inpDepth").value || "3", 10);
      const sections = parseInt($("inpSections").value || "5", 10);
      const model = $("selModel").value;
      const temperature = parseFloat($("inpTemp").value || "0.3");

      showError("");
      $("btnGen").disabled = true; $("btnGen").textContent = "Thinking…";
      BREAD = []; EXP_CACHE.clear(); CONTENT.clear(); READING.clear(); EXPANDED.clear(); CHAT_HISTORY.clear(); CHATTING.clear(); VIDEOS.clear(); FETCHING_VIDEOS.clear(); LEVELS_ENABLED.clear(); ACTIVE_LEVEL.clear(); LEVEL_CONTENT.clear(); LEVEL_READING.clear();
      const resultTitleEl = document.getElementById("resultTitle");
      if (resultTitleEl) resultTitleEl.textContent = topic ? `TOC for: ${topic}` : "No topic yet";

      try {
        let result;
        if (!LIVE) {
          // keep your mock code
          const stamp = slug(topic || "topic");
          const clone = JSON.parse(JSON.stringify(example));
          clone.toc = clone.toc.map(n => ({
            ...n, id: `${stamp}/${n.id}`, title: `${n.title} — ${topic}`,
            children: (n.children||[]).map(c => ({ ...c, id: `${stamp}/${c.id}` }))
          }));
          result = { toc: clone.toc };
        } else {
          const resp = await fetch("/api/toc", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ topic, audience, depth, sections, model, temperature })
          });
          if (!resp.ok) throw new Error(await resp.text());
          result = await resp.json();
        }
        CURRENT_TOC = result.toc || [];
        CURRENT_TOC.forEach(n => EXPANDED.add(n.id));
        const topCountEl = document.getElementById("topCount");
        if (topCountEl) topCountEl.textContent = CURRENT_TOC.length;
        if (NAV_MODE === 'leftnav') {
          renderLeftNavTree();
          // Auto-select first node
          if (CURRENT_TOC.length > 0) {
            const firstNode = findFirstSelectableNode(CURRENT_TOC);
            if (firstNode) {
              selectNodeInLeftNav(firstNode.id);
            }
          }
        } else {
          if (NAV_MODE === 'leftnav') {
          renderLeftNavTree();
        } else {
          if (NAV_MODE === 'leftnav') {
  renderLeftNavTree();
} else {
  renderTree(CURRENT_TOC);
}
        }
        }
        RUNS += 1; 
        const runCountEl = document.getElementById("runCount");
        if (runCountEl) runCountEl.textContent = RUNS;
        
        // Track run history
        RUNS_HISTORY.push({
          ts: new Date().toISOString(),
          model,
          temperature,
          tokens: result.tokens,
          requestSummary: `Generated TOC for "${topic}" (${audience} audience)`
        });
        
        autosave();
      } catch (e) {
        showError(e.message || String(e));
      } finally {
        $("btnGen").disabled = false; $("btnGen").textContent = "Learn";
      }
    }

    function copyJSON() {
      if (!CURRENT_TOC.length) return;
      const text = JSON.stringify({ toc: CURRENT_TOC }, null, 2);
      navigator.clipboard.writeText(text);
    }

    function exportJSON() {
      if (!CURRENT_TOC.length) return;
      const topic = $("inpTopic").value.trim() || "topic";
      blobDownload(`toc-${slug(topic)}.json`, JSON.stringify({ toc: CURRENT_TOC }, null, 2));
    }

    function toMarkdown(nodes, level = 1) {
      let md = "";
      for (const node of nodes) {
        md += `${"#".repeat(Math.min(level, 6))} ${node.title}\n`;
        if (node.description) md += `${node.description}\n`;
        md += `\n`;
        if (node.children?.length) md += toMarkdown(node.children, level + 1);
      }
      return md;
    }

    function exportMD() {
      if (!CURRENT_TOC.length) return;
      const topic = $("inpTopic").value.trim() || "topic";
      const md = `# Table of Contents — ${topic}\n\n` + toMarkdown(CURRENT_TOC, 2);
      blobDownload(`toc-${slug(topic)}.md`, md, "text/markdown");
    }

    // ----------------------- Hooks -----------------------
    $("btnGen").addEventListener("click", generate);
    $("btnSave").addEventListener("click", saveNotebook);
    $("btnOpen").addEventListener("click", openNotebook);
    $("btnCopy").addEventListener("click", copyJSON);
    $("chkLive").addEventListener("change", (e) => { 
      LIVE = e.target.checked; 
      // Update status display if it exists
      const statusText = document.getElementById("statusText");
      if (statusText) {
        statusText.textContent = LIVE ? "Live" : "Mock";
      }
    });
    $("btnUndo").addEventListener("click", undoLastChange);
    
    // Enter key listener for Topic text field
    $("inpTopic").addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !$("btnGen").disabled) {
        e.preventDefault();
        generate();
      }
    });
    
    // Navigation mode toggle listeners
    $("navLeftNav").addEventListener("change", (e) => {
      if (e.target.checked) {
        setNavigationMode('leftnav');
      }
    });
    
    // Left nav collapse toggle
    $("leftNavToggle").addEventListener("click", toggleLeftNav);
    
    $("navInline").addEventListener("change", (e) => {
      if (e.target.checked) {
        setNavigationMode('inline');
      }
    });
    
    // Reading width toggle listeners
    $("readingFull").addEventListener("change", (e) => {
      if (e.target.checked) {
        setReadingWidth('full');
      }
    });
    
    $("readingComfortable").addEventListener("change", (e) => {
      if (e.target.checked) {
        setReadingWidth('comfortable');
      }
    });

    // Selection toolbar event listeners
    $("btnDiveDeep").addEventListener("click", diveDeep);
    $("btnCopySelection").addEventListener("click", copySelection);
    $("btnAskAboutSelection").addEventListener("click", askAboutSelection);

    // Selection handling
    document.addEventListener("selectionchange", () => {
      const selectionInfo = getSelectionInfo();
      if (selectionInfo) {
        showSelectionToolbar(selectionInfo);
      } else {
        hideSelectionToolbar();
      }
    });

    // Also handle mouseup for better selection detection
    document.addEventListener("mouseup", () => {
      setTimeout(() => {
        const selectionInfo = getSelectionInfo();
        if (selectionInfo) {
          showSelectionToolbar(selectionInfo);
        } else {
          hideSelectionToolbar();
        }
      }, 10); // Small delay to ensure selection is complete
    });

    // Hide toolbar on click outside
    document.addEventListener("click", (e) => {
      if (!e.target.closest("#selectionToolbar")) {
        hideSelectionToolbar();
      }
    });

    // Modal close on outside click
    document.addEventListener("click", (e) => {
      const modal = $("visualizationModal");
      if (e.target === modal) {
        closeVisualizationModal();
      }
    });

    // Hide toolbar on scroll
    document.addEventListener("scroll", () => {
      hideSelectionToolbar();
    });

    // Keyboard shortcuts
    document.addEventListener("keydown", (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
        e.preventDefault();
        if (currentSelection) {
          diveDeep();
        }
      }
      if (e.key === 'Escape') {
        hideSelectionToolbar();
      }
    });

    // Settings panel toggle
    function toggleSettings() {
      const panel = document.getElementById('settingsPanel');
      panel.classList.toggle('show');
    }

    // Error display helper
    function showError(message) {
      const errorBox = document.getElementById('errorBox');
      if (message) {
        errorBox.textContent = message;
        errorBox.style.display = 'block';
      } else {
        errorBox.style.display = 'none';
      }
    }

    // Close settings panel when clicking outside
    document.addEventListener('click', (e) => {
      const panel = document.getElementById('settingsPanel');
      const gearIcon = document.querySelector('.gear-icon');
      if (panel && !panel.contains(e.target) && !gearIcon.contains(e.target)) {
        panel.classList.remove('show');
      }
    });

    // Initialize autosave on page load
    document.addEventListener("DOMContentLoaded", () => {
      try {
        // Set up event listeners for settings panel inputs
        document.getElementById('inpTemp').addEventListener('input', (e) => {
          document.getElementById('tempVal').textContent = parseFloat(e.target.value).toFixed(2);
        });

        // Try to load autosave on startup
        if (!loadAutosave()) {
          // If no autosave was loaded, set up autosave for future changes
          autosave();
        }
        updateUndoButton();
        console.log("Topic Browser initialized successfully");
      } catch (error) {
        console.error("Error initializing Topic Browser:", error);
      }
    });
  </script>
</body>
</html>