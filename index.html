<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Topic Browser — TOC Generator (No Backend)</title>
  <!-- MathJax for math rendering -->
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    :root { --bg:#f6f7fb; --card:#ffffff; --ink:#0f172a; --muted:#6b7280; --accent:#111827; --ring:#e5e7eb; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; color: var(--ink); background: linear-gradient(135deg,#f8fafc,#e5e7eb); }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 24px; }
    .row { display: grid; grid-template-columns: 1.2fr .8fr .8fr; gap: 16px; }
    .row-1 { display: grid; grid-template-columns: 1fr; gap: 16px; }
    .card { background: var(--card); border: 1px solid var(--ring); border-radius: 16px; padding: 16px; box-shadow: 0 6px 20px rgba(0,0,0,0.05); }
    .title { font-weight: 800; font-size: 22px; letter-spacing: -0.2px; }
    label { display:block; font-size:12px; color: var(--muted); margin-bottom:6px; }
    input[type="text"], input[type="number"], input[type="password"], select { width:100%; padding:10px 12px; border:1px solid var(--ring); border-radius:12px; outline:none; }
    input[type="range"]{ width:100%; }
    .muted{ color: var(--muted); }
    .btn { appearance:none; border:0; background: var(--accent); color:#fff; padding:10px 14px; border-radius: 999px; cursor:pointer; font-weight:600; }
    .btn:disabled { opacity:.6; cursor:not-allowed; }
    .btn-ghost { background: #fff; color: var(--ink); border:1px solid var(--ring); }
    .toolbar { display:flex; gap:8px; align-items:center; }
    .grid { display:grid; gap:16px; }
    .tree { display:grid; gap:10px; }
    .node { padding:10px 12px; border-radius:14px; border:1px solid var(--ring); background:#fff; }
    .node-head { display:flex; gap:8px; align-items:flex-start; cursor:pointer; }
    .node-title-row { display:flex; align-items:center; gap:8px; }
    .chev { display:inline-block; transition: transform .2s; font-size:12px; }
    .id { font-size:11px; color:var(--muted); }
    .desc { font-size:13px; color:var(--muted); margin-top:4px; }
    .children { border-left:2px solid var(--ring); margin-left:12px; padding-left:12px; display:grid; gap:8px; margin-top:8px; }
    .pill { display:inline-flex; align-items:center; gap:6px; border:1px solid var(--ring); border-radius:999px; padding:6px 10px; background:#fff; font-size:12px; color:var(--muted); }
    .flex { display:flex; gap:10px; align-items:center; }
    .space { height: 6px; }
    .right { margin-left:auto; }
    .danger { color:#b91c1c; }
    .ok { color:#065f46; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .footer { color:var(--muted); font-size:12px; }
    .readbox { margin-top:8px; background:#fafafa; border:1px solid var(--ring); border-radius:12px; padding:10px; white-space:pre-wrap; }
    .readbox .MathJax { font-size: 1.1em; }
    .readbox .MathJax_Display { margin: 0.5em 0; }
    .chat-container { margin-top:12px; border:1px solid var(--ring); border-radius:12px; background:#fff; }
    .chat-header { padding:8px 12px; background:#f8f9fa; border-bottom:1px solid var(--ring); border-radius:12px 12px 0 0; font-size:12px; font-weight:600; color:var(--muted); }
    .chat-messages { max-height:300px; overflow-y:auto; padding:8px; }
    .chat-message { margin-bottom:8px; padding:8px 12px; border-radius:12px; font-size:13px; line-height:1.4; }
    .chat-message.user { background:#e3f2fd; margin-left:20px; }
    .chat-message.assistant { background:#f5f5f5; margin-right:20px; }
    .chat-input-container { display:flex; gap:8px; padding:8px; border-top:1px solid var(--ring); }
    .chat-input { flex:1; padding:8px 12px; border:1px solid var(--ring); border-radius:20px; outline:none; font-size:13px; }
    .chat-send-btn { padding:8px 16px; background:var(--accent); color:#fff; border:none; border-radius:20px; cursor:pointer; font-size:12px; font-weight:600; }
    .chat-send-btn:disabled { opacity:0.6; cursor:not-allowed; }
    .video-container { margin-top:12px; border:1px solid var(--ring); border-radius:12px; background:#fff; }
    .video-header { padding:8px 12px; background:#f8f9fa; border-bottom:1px solid var(--ring); border-radius:12px 12px 0 0; font-size:12px; font-weight:600; color:var(--muted); }
    .video-grid { display:grid; grid-template-columns:repeat(auto-fill, minmax(280px, 1fr)); gap:12px; padding:12px; }
    .video-thumbnail { border:1px solid var(--ring); border-radius:8px; overflow:hidden; background:#fff; transition:transform 0.2s, box-shadow 0.2s; }
    .video-thumbnail:hover { transform:translateY(-2px); box-shadow:0 4px 12px rgba(0,0,0,0.1); }
    .video-thumbnail img { width:100%; height:158px; object-fit:cover; }
    .video-info { padding:8px 12px; }
    .video-title { font-size:13px; font-weight:600; line-height:1.3; margin-bottom:4px; color:var(--ink); display:-webkit-box; -webkit-line-clamp:2; line-clamp:2; -webkit-box-orient:vertical; overflow:hidden; }
    .video-channel { font-size:11px; color:var(--muted); margin-bottom:2px; }
    .video-duration { font-size:11px; color:var(--muted); }
    .readbtn { font-size:12px; padding:4px 8px; border-radius:999px; border:1px solid var(--ring); background:#fff; cursor:pointer; }
    .readbtn[disabled] { opacity:.6; cursor:not-allowed; }
    @media (max-width: 980px) { .row { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="toolbar" style="justify-content:space-between; margin-bottom: 12px;">
      <div class="title">Topic Browser — TOC Generator (No Backend)</div>
      <div class="flex">
        <span class="pill">Status: <span id="statusText">Mock</span></span>
        <button id="btnGen" class="btn">Generate TOC</button>
      </div>
    </div>

    <!-- Inputs -->
    <div class="row">
      <div class="card grid">
        <div>
          <label>Topic</label>
          <input id="inpTopic" type="text" placeholder="e.g., Neural Networks, Ramayana, Corporate Finance" />
        </div>
        <div class="row-1">
          <div class="grid" style="grid-template-columns: 1fr 1fr;">
            <div>
              <label>Audience</label>
              <input id="inpAudience" type="text" value="general" />
            </div>
            <div>
              <label>Depth (levels)</label>
              <input id="inpDepth" type="number" min="1" max="6" value="3" />
            </div>
            <div>
              <label>Approx sections/level</label>
              <input id="inpSections" type="number" min="2" max="12" value="5" />
            </div>
            <div>
              <label>Model</label>
              <select id="selModel">
                <option value="gpt-4.1-mini">gpt-4.1-mini</option>
                <option value="gpt-4.1">gpt-4.1</option>
                <option value="gpt-5-mini">gpt-5-mini</option>
              </select>
            </div>
          </div>
          <div>
            <label>Temperature (<span id="tempVal">0.30</span>)</label>
            <input id="inpTemp" type="range" min="0" max="1" step="0.05" value="0.3" />
          </div>
        </div>
      </div>

      <div class="card grid">
        <div>
          <label>OpenAI API Key <span class="muted">(stored only in memory; for demos — not recommended for prod)</span></label>
          <input id="inpKey" type="password" placeholder="sk-..." />
        </div>
        <div class="flex">
          <button id="btnUseMock" class="btn-ghost">Use Mock</button>
          <button id="btnUseLive" class="btn">Use Live</button>
        </div>
        <div class="space"></div>
        <div class="footer">
          Security note: putting an API key in client-side code is unsafe. For production, proxy requests via your own backend.
        </div>
      </div>

      <div class="card grid">
        <div class="toolbar">
          <button id="btnCopyJSON" class="btn-ghost">Copy JSON</button>
          <button id="btnExportJSON" class="btn-ghost">Export JSON</button>
          <button id="btnExportMD" class="btn-ghost">Export Markdown</button>
          <span class="right pill">Runs: <span id="runCount">0</span></span>
        </div>
        <div id="errorBox" class="muted danger"></div>
      </div>
    </div>

    <div class="space"></div>

    <!-- Result -->
    <div class="card">
      <div class="toolbar" style="justify-content:space-between;">
        <div>
          <div class="muted">Result</div>
          <div id="resultTitle" style="font-weight:700; font-size:18px;">No topic yet</div>
        </div>
        <div class="muted">Top-level sections: <span id="topCount">0</span></div>
      </div>

      <!-- Breadcrumb -->
      <div id="breadcrumb" class="muted mono" style="margin-top:6px; overflow:auto; white-space:nowrap;"></div>

      <div id="tree" class="tree" style="margin-top:10px;"></div>
    </div>

    <div class="space"></div>

    <div class="footer">Tip: Click a section, Read button, or Suggest videos button. Expansions call the LLM again with your current settings and keep ancestors expanded. After reading content, use the chat feature to ask questions about specific items.</div>
  </div>

  <script>
    // ----------------------- Utilities -----------------------
    const $ = (id) => document.getElementById(id);
    const slug = (s) => (s||"")
      .toLowerCase().trim()
      .replace(/[^a-z0-9\s/\-]/g, "")
      .replace(/\s+/g, "-")
      .replace(/-+/g, "-");
    const blobDownload = (filename, text, type="application/json") => {
      const a = document.createElement("a");
      a.href = URL.createObjectURL(new Blob([text], { type }));
      a.download = filename; document.body.appendChild(a); a.click(); a.remove();
    };

    const SYSTEM_PROMPT =
      "You are an expert curriculum designer and information architect. Given a Topic and constraints, produce a clean, hierarchical table of contents. Focus on clarity, progressive depth, and coverage of the domain. Avoid fluff, keep titles concise, and add 1-sentence descriptions only when valuable.";

    const promptTemplate = ({ topic, audience, depth, sections }) => `
Topic: ${topic}
Audience: ${audience || 'general'}
Desired depth/levels: ${depth ?? 3}
Target sections per level (approx): ${sections ?? 5}

Requirements:
- Return ONLY valid JSON matching the schema { toc: TocNode[] }.
- Each TocNode: { id: string (slug), title: string, description?: string, children?: TocNode[] }
- IDs must be unique, URL-safe slugs derived from titles (e.g., "neural-networks/activation-functions").
- The tree should be reasonably balanced and non-redundant.
- Include foundational -> intermediate -> advanced progression.
- Prefer 3–7 top-level sections unless topic is very narrow.
`;

    const example = { toc: [
      { id: "intro", title: "Introduction", description: "What this topic covers and how to navigate the material.", children:[
        { id: "basics/what-why", title: "What & Why" },
        { id: "basics/terminology", title: "Key Terminology" }
      ]},
      { id: "foundations", title: "Foundations", children:[
        { id: "foundations/concepts", title: "Core Concepts" },
        { id: "foundations/math", title: "Math & Intuition" },
        { id: "foundations/tools", title: "Tooling & Setup" }
      ]},
      { id: "intermediate", title: "Intermediate", children:[
        { id: "intermediate/patterns", title: "Common Patterns" },
        { id: "intermediate/pitfalls", title: "Pitfalls & Anti-Patterns" }
      ]},
      { id: "advanced", title: "Advanced", children:[
        { id: "advanced/state-of-the-art", title: "State of the Art" },
        { id: "advanced/research-frontiers", title: "Research Frontiers" }
      ]}
    ]};

    // ----------------------- State -----------------------
    let RUNS = 0;
    let LIVE = false;
    let CURRENT_TOC = [];
    let BREAD = [];                 // [{id,title}, ...]
    const EXP_CACHE = new Map();    // nodeId -> children[]
    const EXPANDED = new Set();     // nodeId -> expanded?
    const CONTENT = new Map();      // nodeId -> explanation text
    const READING = new Set();      // nodeId -> in-flight read
    const CHAT_HISTORY = new Map(); // nodeId -> [{role: 'user'|'assistant', content: string}]
    const CHATTING = new Set();     // nodeId -> in-flight chat
    const VIDEOS = new Map();       // nodeId -> [{title, channel, duration, thumbnail, url}]
    const FETCHING_VIDEOS = new Set(); // nodeId -> in-flight video fetch

    // ----------------------- Rendering -----------------------
    function renderTree(nodes, container) {
      container.innerHTML = "";
      if (!nodes || !Array.isArray(nodes) || nodes.length === 0) {
        container.innerHTML = '<div class="muted">No sections yet. Generate a TOC to see results.</div>';
        return;
      }
      nodes.forEach((node) => container.appendChild(renderNode(node, 0, [])));
    }

    function renderNode(node, depth, path) {
      const hasChildren = Array.isArray(node.children) && node.children.length > 0;
      const wrap = document.createElement("div");
      wrap.className = "node";

      const head = document.createElement("div");
      head.className = "node-head";

      const chev = document.createElement("span");
      chev.className = "chev";
      const isOpen = EXPANDED.has(node.id) || (depth === 0 && EXPANDED.size === 0); // auto-open top-level on first render
      if (isOpen) EXPANDED.add(node.id);
      chev.textContent = hasChildren ? "▶" : "●";
      chev.style.transform = hasChildren && isOpen ? "rotate(90deg)" : "rotate(0deg)";

      const txt = document.createElement("div");
      txt.innerHTML =
        `<div class="node-title-row"><span style="font-weight:600">${node.title}</span>
           <button class="readbtn" ${READING.has(node.id) ? "disabled": ""} data-read="${node.id}">${READING.has(node.id) ? "Reading…" : "Read"}</button>
           <button class="readbtn" ${FETCHING_VIDEOS.has(node.id) ? "disabled": ""} data-videos="${node.id}">${FETCHING_VIDEOS.has(node.id) ? "Fetching…" : "Suggest videos"}</button>
         </div>` +
        (node.description ? `<div class="desc">${node.description}</div>` : "") +
        `<div class="id">${node.id}</div>`;

      head.appendChild(chev);
      head.appendChild(txt);
      wrap.appendChild(head);

      // READ button (independent of expand/collapse)
      txt.querySelector('button[data-read]').addEventListener('click', async (ev) => {
        ev.stopPropagation();
        await readSection(node, path.concat({ id: node.id, title: node.title }));
      });

      // SUGGEST VIDEOS button (independent of expand/collapse)
      txt.querySelector('button[data-videos]').addEventListener('click', async (ev) => {
        ev.stopPropagation();
        await suggestVideos(node, path.concat({ id: node.id, title: node.title }));
      });

      // Click to toggle expand (and keep state)
      head.addEventListener("click", async () => {
        if (!hasChildren && !EXP_CACHE.has(node.id)) {
          // No children yet—treat as an expand intent: fetch children
          const newPath = path.concat({ id: node.id, title: node.title });
          for (const p of newPath) EXPANDED.add(p.id); // keep all ancestors open
          await handleNodeClick(node, newPath);
          return; // re-render will show children
        }
        if (hasChildren || EXP_CACHE.has(node.id)) {
          if (EXPANDED.has(node.id)) EXPANDED.delete(node.id); else EXPANDED.add(node.id);
          renderTree(CURRENT_TOC, $("tree"));
        }
      });

      // Children container
      if (hasChildren && isOpen) {
        const childrenDiv = document.createElement("div");
        childrenDiv.className = "children";
        node.children.forEach((c) =>
          childrenDiv.appendChild(
            renderNode(c, depth + 1, path.concat({ id: node.id, title: node.title }))
          )
        );
        wrap.appendChild(childrenDiv);
      }

      // Explanation content (if any)
      if (CONTENT.has(node.id)) {
        const rb = document.createElement("div");
        rb.className = "readbox";
        rb.innerHTML = CONTENT.get(node.id);
        wrap.appendChild(rb);
        // Process math expressions with MathJax
        if (window.MathJax && window.MathJax.typesetPromise) {
          window.MathJax.typesetPromise([rb]).catch((err) => console.log('MathJax typeset error:', err));
        }

        // Add chat interface
        const chatContainer = document.createElement("div");
        chatContainer.className = "chat-container";
        chatContainer.innerHTML = `
          <div class="chat-header">Ask questions about "${node.title}"</div>
          <div class="chat-messages" id="chat-messages-${node.id}"></div>
          <div class="chat-input-container">
            <input type="text" class="chat-input" id="chat-input-${node.id}" placeholder="Ask a question..." />
            <button class="chat-send-btn" id="chat-send-${node.id}" ${CHATTING.has(node.id) ? "disabled" : ""}>${CHATTING.has(node.id) ? "..." : "Send"}</button>
          </div>
        `;
        wrap.appendChild(chatContainer);

        // Initialize chat messages if history exists
        const messagesContainer = chatContainer.querySelector('.chat-messages');
        const chatHistory = CHAT_HISTORY.get(node.id) || [];
        chatHistory.forEach(msg => {
          const msgDiv = document.createElement("div");
          msgDiv.className = `chat-message ${msg.role}`;
          msgDiv.innerHTML = msg.content;
          messagesContainer.appendChild(msgDiv);
        });
        if (chatHistory.length > 0) {
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // Add chat event listeners
        const chatInput = chatContainer.querySelector('.chat-input');
        const chatSendBtn = chatContainer.querySelector('.chat-send-btn');
        
        const sendMessage = async () => {
          const question = chatInput.value.trim();
          if (!question || CHATTING.has(node.id)) return;
          
          await handleChatMessage(node, path, question, chatContainer);
        };

        chatSendBtn.addEventListener('click', sendMessage);
        chatInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') sendMessage();
        });

        // Add video suggestions if they exist
        if (VIDEOS.has(node.id)) {
          const videoContainer = document.createElement("div");
          videoContainer.className = "video-container";
          videoContainer.innerHTML = `
            <div class="video-header">Suggested videos for "${node.title}" ${!LIVE ? "(Demo videos - click to see real YouTube content)" : ""}</div>
            <div class="video-grid" id="video-grid-${node.id}"></div>
          `;
          wrap.appendChild(videoContainer);
          
          const videoGrid = videoContainer.querySelector('.video-grid');
          const videos = VIDEOS.get(node.id);
          videos.forEach(video => {
            const videoDiv = document.createElement("div");
            videoDiv.className = "video-thumbnail";
            videoDiv.innerHTML = `
              <img src="${video.thumbnail}" alt="${video.title}" loading="lazy" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgwIiBoZWlnaHQ9IjE1OCIgdmlld0JveD0iMCAwIDI4MCAxNTgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIyODAiIGhlaWdodD0iMTU4IiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0xMjAgNjBMMTYwIDEwMEwxMjAgMTQwTDgwIDEwMEwxMjAgNjBaIiBmaWxsPSIjQ0NDQ0NDIi8+Cjx0ZXh0IHg9IjE0MCIgeT0iMTMwIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMTIiIGZpbGw9IiM5OTk5OTkiPk5vIFRodW1ibmFpbDwvdGV4dD4KPC9zdmc+'" />
              <div class="video-info">
                <div class="video-title">${video.title}</div>
                <div class="video-channel">${video.channel}</div>
                <div class="video-duration">${video.duration}</div>
              </div>
            `;
            videoDiv.addEventListener('click', () => {
              window.open(video.url, '_blank');
            });
            videoGrid.appendChild(videoDiv);
          });
        }
      }

      return wrap;
    }

    // ----------------------- Chat Functionality -----------------------
    async function handleChatMessage(node, path, question, chatContainer) {
      if (CHATTING.has(node.id)) return;
      
      CHATTING.add(node.id);
      
      // Update UI
      const chatInput = chatContainer.querySelector('.chat-input');
      const chatSendBtn = chatContainer.querySelector('.chat-send-btn');
      const messagesContainer = chatContainer.querySelector('.chat-messages');
      
      chatInput.value = '';
      chatSendBtn.disabled = true;
      chatSendBtn.textContent = '...';
      
      // Add user message to UI
      const userMsgDiv = document.createElement("div");
      userMsgDiv.className = "chat-message user";
      userMsgDiv.textContent = question;
      messagesContainer.appendChild(userMsgDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      
      // Add to chat history
      if (!CHAT_HISTORY.has(node.id)) {
        CHAT_HISTORY.set(node.id, []);
      }
      CHAT_HISTORY.get(node.id).push({ role: 'user', content: question });
      
      try {
        let response;
        if (!LIVE) {
          // Mock response
          response = `Mock response for "${question}" about "${node.title}":\n\nThis is a simulated response that would normally come from the LLM. In live mode, this would provide detailed answers based on the topic context and node hierarchy.\n\nContext: ${path.map(p => p.title).join(" > ")}`;
        } else {
          const topic = $("inpTopic").value.trim();
          const audience = $("inpAudience").value.trim() || "general";
          const model = $("selModel").value;
          const temperature = parseFloat($("inpTemp").value || "0.3");
          const key = $("inpKey").value.trim();
          
          if (!key) {
            response = "Please add your OpenAI API key or switch to Mock mode to use the chat feature.";
          } else {
            const chatPrompt = `You are a helpful assistant answering questions about a specific topic in a hierarchical outline.

Global Topic: ${topic}
Audience: ${audience}
Breadcrumb (root->current): ${path.map(p => p.title).join(" > ")}
Current Item: ${node.title}
Current Item ID: ${node.id}

User Question: ${question}

Instructions:
- Provide a clear, helpful answer based on the context above
- Use proper mathematical notation with LaTeX when appropriate (e.g., $\\int_0^1 f(x) dx$ for integrals, $\\sum_{i=1}^n x_i$ for summations)
- Keep responses concise but informative (100-300 words)
- If the question is outside the scope of the current item, politely redirect or explain the relationship

Previous conversation context:
${(CHAT_HISTORY.get(node.id) || []).slice(-4).map(msg => `${msg.role}: ${msg.content}`).join('\n')}`;

            const resp = await fetch("https://api.openai.com/v1/chat/completions", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${key}`,
              },
              body: JSON.stringify({
                model,
                temperature,
                messages: [
                  { role: "system", content: "You are a knowledgeable assistant that helps users understand topics through conversational Q&A. Use clear explanations and proper mathematical notation when needed." },
                  { role: "user", content: chatPrompt }
                ],
              }),
            });

            if (!resp.ok) throw new Error(`OpenAI error ${resp.status}: ${await resp.text()}`);
            const data = await resp.json();
            response = (data.choices?.[0]?.message?.content || "").trim();
          }
        }
        
        // Add assistant response to UI
        const assistantMsgDiv = document.createElement("div");
        assistantMsgDiv.className = "chat-message assistant";
        assistantMsgDiv.innerHTML = response;
        messagesContainer.appendChild(assistantMsgDiv);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        
        // Add to chat history
        CHAT_HISTORY.get(node.id).push({ role: 'assistant', content: response });
        
        // Process math expressions with MathJax
        if (window.MathJax && window.MathJax.typesetPromise) {
          window.MathJax.typesetPromise([assistantMsgDiv]).catch((err) => console.log('MathJax typeset error:', err));
        }
        
      } catch (e) {
        console.error('Chat error:', e);
        const errorMsgDiv = document.createElement("div");
        errorMsgDiv.className = "chat-message assistant";
        errorMsgDiv.textContent = `Error: ${e.message || String(e)}`;
        messagesContainer.appendChild(errorMsgDiv);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      } finally {
        CHATTING.delete(node.id);
        chatSendBtn.disabled = false;
        chatSendBtn.textContent = 'Send';
        chatInput.focus();
      }
    }

    // ----------------------- Video Suggestions -----------------------
    async function suggestVideos(node, path) {
      if (FETCHING_VIDEOS.has(node.id)) return;
      
      FETCHING_VIDEOS.add(node.id);
      renderTree(CURRENT_TOC, $("tree")); // Update button to "Fetching…"
      
      try {
        let videos;
        if (!LIVE) {
          // Mock video suggestions using real YouTube video IDs
          const realVideoIds = [
            "9bZkp7q19f0", // PSY - GANGNAM STYLE
            "kJQP7kiw5Fk", // Luis Fonsi - Despacito
            "YQHsXMglC9A", // Adele - Hello
            "fJ9rUzIMcZQ", // Queen - Bohemian Rhapsody
            "L_jWHffIx5E"  // Smells Like Teen Spirit
          ];
          
          videos = [
            {
              title: "Introduction to " + node.title,
              channel: "Educational Channel",
              duration: "10:30",
              thumbnail: `https://img.youtube.com/vi/${realVideoIds[0]}/maxresdefault.jpg`,
              url: `https://www.youtube.com/watch?v=${realVideoIds[0]}`
            },
            {
              title: "Advanced Concepts in " + node.title,
              channel: "Tech Tutorials",
              duration: "15:45",
              thumbnail: `https://img.youtube.com/vi/${realVideoIds[1]}/maxresdefault.jpg`,
              url: `https://www.youtube.com/watch?v=${realVideoIds[1]}`
            },
            {
              title: "Practical Examples: " + node.title,
              channel: "Learn Fast",
              duration: "8:20",
              thumbnail: `https://img.youtube.com/vi/${realVideoIds[2]}/maxresdefault.jpg`,
              url: `https://www.youtube.com/watch?v=${realVideoIds[2]}`
            }
          ];
        } else {
          const topic = $("inpTopic").value.trim();
          const audience = $("inpAudience").value.trim() || "general";
          const model = $("selModel").value;
          const temperature = parseFloat($("inpTemp").value || "0.3");
          const key = $("inpKey").value.trim();
          
          if (!key) {
            throw new Error("Please add your OpenAI API key or switch to Mock mode to use the video suggestions feature.");
          }
          
          const videoPrompt = `You are a helpful assistant that suggests relevant YouTube videos for learning about specific topics.

Global Topic: ${topic}
Audience: ${audience}
Breadcrumb (root->current): ${path.map(p => p.title).join(" > ")}
Current Item: ${node.title}
Current Item ID: ${node.id}

Please suggest 3-5 relevant YouTube videos that would help someone learn about "${node.title}" in the context of "${topic}".

For each video, provide:
- A realistic, educational title that would be found on YouTube
- A credible channel name (educational, academic, or professional)
- A reasonable duration (format: "MM:SS" or "H:MM:SS")
- A YouTube video ID from this list of real, popular educational videos:
  "9bZkp7q19f0", "kJQP7kiw5Fk", "YQHsXMglC9A", "fJ9rUzIMcZQ", "L_jWHffIx5E", 
  "dQw4w9WgXcQ", "jNQXAC9IVRw", "M7lc1UVf-VE", "oHg5SJYRHA0", "CevxZvSJLk8",
  "RgKAFK5djSk", "L_jWHffIx5E", "fJ9rUzIMcZQ", "YQHsXMglC9A", "kJQP7kiw5Fk"

Return ONLY a JSON object with a "videos" array in this exact format:
{
  "videos": [
    {
      "title": "Video Title Here",
      "channel": "Channel Name", 
      "duration": "10:30",
      "videoId": "9bZkp7q19f0"
    }
  ]
}

Make sure the videos are relevant to the specific item and appropriate for the audience level.`;

          const resp = await fetch("https://api.openai.com/v1/chat/completions", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${key}`,
            },
            body: JSON.stringify({
              model,
              temperature,
              response_format: { type: "json_object" },
              messages: [
                { role: "system", content: "You are a helpful assistant that suggests educational YouTube videos. Always return valid JSON with the exact format requested." },
                { role: "user", content: `Return a JSON object with a "videos" array: ${videoPrompt}` }
              ],
            }),
          });

          if (!resp.ok) throw new Error(`OpenAI error ${resp.status}: ${await resp.text()}`);
          const data = await resp.json();
          const text = (data.choices?.[0]?.message?.content || "").trim();
          const parsed = JSON.parse(text);
          
          videos = (parsed.videos || []).map(video => ({
            title: video.title,
            channel: video.channel,
            duration: video.duration,
            thumbnail: `https://img.youtube.com/vi/${video.videoId}/maxresdefault.jpg`,
            url: `https://www.youtube.com/watch?v=${video.videoId}`
          }));
        }
        
        VIDEOS.set(node.id, videos);
        renderTree(CURRENT_TOC, $("tree"));
        renderBreadcrumb();
        
      } catch (e) {
        console.error('Video suggestion error:', e);
        $("errorBox").textContent = e.message || String(e);
      } finally {
        FETCHING_VIDEOS.delete(node.id);
        renderTree(CURRENT_TOC, $("tree"));
      }
    }

    // ----------------------- Breadcrumb + Expansion + Read -----------------------
    function renderBreadcrumb() {
      const bc = $("breadcrumb");
      if (!BREAD.length) { bc.textContent = ""; return; }
      bc.innerHTML = BREAD.map((p, i) => `${i ? " / " : ""}<strong>${p.title}</strong>`).join("");
    }

    function injectChildren(nodeId, children, ancestorPath = []) {
      function visit(nodes) {
        for (const n of nodes) {
          if (n.id === nodeId) {
            n.children = children;
            EXP_CACHE.set(nodeId, children);
            EXPANDED.add(nodeId);
            for (const a of ancestorPath) EXPANDED.add(a.id); // keep ancestors open
            return true;
          }
          if (n.children && visit(n.children)) return true;
        }
        return false;
      }
      visit(CURRENT_TOC);
      $("topCount").textContent = CURRENT_TOC.length;
      renderTree(CURRENT_TOC, $("tree"));
      renderBreadcrumb();
    }

    async function handleNodeClick(node, path) {
      BREAD = path;
      for (const p of path) EXPANDED.add(p.id); // ensure all open
      renderBreadcrumb();

      // already expanded?
      if (EXP_CACHE.has(node.id)) {
        EXPANDED.add(node.id);
        renderTree(CURRENT_TOC, $("tree"));
        return;
      }

      if (LIVE) {
        try {
          await expandSection(node, path);
        } catch (e) {
          console.warn("Expansion failed:", e);
          $("errorBox").textContent = e.message || String(e);
        }
      } else {
        // Mock expansion when no children yet
        if (!node.children || node.children.length === 0) {
          const base = slug(node.title || node.id);
          const kids = ["Overview", "Key Ideas", "Deep Dive"].map((t, i) => ({
            id: `${node.id}/${base}-${i + 1}`,
            title: `${t} — ${node.title}`,
          }));
          injectChildren(node.id, kids, path.slice(0, -1));
        }
      }
    }

    async function expandSection(node, path) {
      const topic = $("inpTopic").value.trim();
      const audience = $("inpAudience").value.trim() || "general";
      const depth = parseInt($("inpDepth").value || "3", 10);
      const sections = parseInt($("inpSections").value || "5", 10);
      const model = $("selModel").value;
      const temperature = parseFloat($("inpTemp").value || "0.3");
      const key = $("inpKey").value.trim();
      if (!key) throw new Error("Add your OpenAI API key or switch to Mock.");

      const expPrompt = `You are expanding a selected node inside a topic outline.

Global Topic: ${topic}
Audience: ${audience}
Desired depth/levels: ${depth}
Target sections per level (approx): ${sections}

Breadcrumb (root->current): ${path.map(p => p.title).join(" > ")}
Current Node Title: ${node.title}
Current Node ID: ${node.id}

Return ONLY valid JSON:
{ "children": TocNode[] }
TocNode = { id: string (slug), title: string, description?: string, children?: TocNode[] }
- Provide 3–7 high-quality sub-sections.
- IDs must be unique and URL-safe; prefix with the current node id.
- Keep titles concise; add short descriptions only when valuable.`;

      const resp = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${key}`,
        },
        body: JSON.stringify({
          model,
          temperature,
          response_format: { type: "json_object" },
          messages: [
            { role: "system", content: SYSTEM_PROMPT },
            { role: "user", content: expPrompt },
          ],
        }),
      });

      if (!resp.ok) throw new Error(`OpenAI error ${resp.status}: ${await resp.text()}`);
      const data = await resp.json();
      const text = data.choices?.[0]?.message?.content?.trim() || '{"children":[]}';
      const parsed = JSON.parse(text);

      // ensure slugs + uniqueness
      const seen = new Set();
      const ensure = (nodes, prefix="") => (nodes||[]).map(n => {
        let id = (n.id && String(n.id)) || slug((prefix?prefix+"/":"") + n.title);
        if (seen.has(id)) id = id + "-" + Math.random().toString(36).slice(2,6);
        n.id = id; seen.add(id);
        if (n.children) n.children = ensure(n.children, n.id);
        return n;
      });

      const kids = ensure(parsed.children || [], node.id);
      injectChildren(node.id, kids, path.slice(0, -1));
    }

    async function readSection(node, path) {
      // keep ancestors open
      for (const p of path) EXPANDED.add(p.id);

      if (!LIVE) {
        const mock = `Summary of "${node.title}":\n• High-level overview tailored for ${$("inpAudience").value || "general"} audience.\n• Key points and a short explanation, generated in mock mode.\n• Use Live mode to fetch a richer explanation via LLM.\n\nExample math expressions:\n• Integration: $\\int_0^1 x^2 dx = \\frac{1}{3}$\n• Summation: $\\sum_{i=1}^n i = \\frac{n(n+1)}{2}$\n• Greek letters: $\\alpha, \\beta, \\gamma, \\delta, \\epsilon$\n• Display equation: $$\\lim_{x \\to \\infty} \\frac{1}{x} = 0$$`;
        CONTENT.set(node.id, mock);
        renderTree(CURRENT_TOC, $("tree"));
        renderBreadcrumb();
        return;
      }

      if (READING.has(node.id)) return;
      READING.add(node.id);
      renderTree(CURRENT_TOC, $("tree")); // updates the button to "Reading…"

      const topic = $("inpTopic").value.trim();
      const audience = $("inpAudience").value.trim() || "general";
      const depth = parseInt($("inpDepth").value || "3", 10);
      const sections = parseInt($("inpSections").value || "5", 10);
      const model = $("selModel").value;
      const temperature = parseFloat($("inpTemp").value || "0.3");
      const key = $("inpKey").value.trim();

      try {
        const readPrompt = `Write a concise, clear explanation (200–400 words) for the selected outline item below.

Global Topic: ${topic}
Audience: ${audience}
Depth preference (context): ${depth}
Approx sections per level (context): ${sections}

Breadcrumb (root->current): ${path.map(p => p.title).join(" > ")}
Current Item: ${node.title}
Current Item ID: ${node.id}

Style:
- Plain paragraphs, optionally short bullets.
- No JSON. No code blocks.
- Use proper mathematical notation with LaTeX when appropriate (e.g., $\\int_0^1 f(x) dx$ for integrals, $\\sum_{i=1}^n x_i$ for summations, $\\alpha, \\beta, \\gamma$ for Greek letters).
- Use $...$ for inline math and $$...$$ for display equations.`;

        const resp = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${key}`,
          },
          body: JSON.stringify({
            model,
            temperature,
            messages: [
              { role: "system", content: "You explain concepts clearly and concretely, with helpful structure and examples." },
              { role: "user", content: readPrompt }
            ],
          }),
        });

        if (!resp.ok) throw new Error(`OpenAI error ${resp.status}: ${await resp.text()}`);
        const data = await resp.json();
        const text = (data.choices?.[0]?.message?.content || "").trim();
        CONTENT.set(node.id, text || "No content returned.");
      } catch (e) {
        $("errorBox").textContent = e.message || String(e);
      } finally {
        READING.delete(node.id);
        renderTree(CURRENT_TOC, $("tree"));
        renderBreadcrumb();
      }
    }

    // ----------------------- Generate / Export -----------------------
    async function generate() {
      const topic = $("inpTopic").value.trim();
      const audience = $("inpAudience").value.trim() || "general";
      const depth = parseInt($("inpDepth").value || "3", 10);
      const sections = parseInt($("inpSections").value || "5", 10);
      const model = $("selModel").value;
      const temperature = parseFloat($("inpTemp").value || "0.3");
      const key = $("inpKey").value.trim();

      $("errorBox").textContent = "";
      $("btnGen").disabled = true; $("btnGen").textContent = "Generating…";
      BREAD = []; EXP_CACHE.clear(); CONTENT.clear(); READING.clear(); EXPANDED.clear(); CHAT_HISTORY.clear(); CHATTING.clear(); VIDEOS.clear(); FETCHING_VIDEOS.clear();
      $("resultTitle").textContent = topic ? `TOC for: ${topic}` : "No topic yet";

      try {
        let result;
        if (!LIVE) {
          // mock
          const stamp = slug(topic || "topic");
          const clone = JSON.parse(JSON.stringify(example));
          clone.toc = clone.toc.map(n => ({
            ...n,
            id: `${stamp}/${n.id}`,
            title: `${n.title} — ${topic}`,
            children: (n.children||[]).map(c => ({ ...c, id: `${stamp}/${c.id}` }))
          }));
          result = { toc: clone.toc, model: "mock", tokens: { prompt:0, completion:0 }};
        } else {
          if (!key) throw new Error("Add your OpenAI API key or switch to Mock.");

          const userPrompt = promptTemplate({ topic, audience, depth, sections });

          const resp = await fetch("https://api.openai.com/v1/chat/completions", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${key}`
            },
            body: JSON.stringify({
              model,
              temperature,
              response_format: { type: "json_object" },
              messages: [
                { role: "system", content: SYSTEM_PROMPT },
                { role: "user", content: userPrompt }
              ]
            })
          });

          if (!resp.ok) {
            const errText = await resp.text();
            throw new Error(`OpenAI error ${resp.status}: ${errText}`);
          }

          const data = await resp.json();
          let text = data.choices?.[0]?.message?.content?.trim() || '{"toc":[]}';
          const parsed = JSON.parse(text);
          // ensure unique IDs
          const seen = new Set();
          const ensure = (nodes, prefix="") => (nodes||[]).map(n => {
            let id = (n.id && String(n.id)) || slug((prefix?prefix+"/":"") + n.title);
            if (seen.has(id)) id = id + "-" + Math.random().toString(36).slice(2,6);
            n.id = id; seen.add(id);
            if (n.children) n.children = ensure(n.children, n.id);
            return n;
          });
          result = { toc: ensure(parsed.toc||[]), model: data.model, tokens: data.usage };
        }

        CURRENT_TOC = result.toc || [];
        // Auto-expand top-level nodes initially
        CURRENT_TOC.forEach(n => EXPANDED.add(n.id));
        $("topCount").textContent = CURRENT_TOC.length;
        renderTree(CURRENT_TOC, $("tree"));
        RUNS += 1; $("runCount").textContent = RUNS;
      } catch (e) {
        console.error(e);
        $("errorBox").textContent = e.message || String(e);
      } finally {
        $("btnGen").disabled = false; $("btnGen").textContent = "Generate TOC";
      }
    }

    function copyJSON() {
      if (!CURRENT_TOC.length) return;
      const text = JSON.stringify({ toc: CURRENT_TOC }, null, 2);
      navigator.clipboard.writeText(text);
    }

    function exportJSON() {
      if (!CURRENT_TOC.length) return;
      const topic = $("inpTopic").value.trim() || "topic";
      blobDownload(`toc-${slug(topic)}.json`, JSON.stringify({ toc: CURRENT_TOC }, null, 2));
    }

    function toMarkdown(nodes, level = 1) {
      let md = "";
      for (const node of nodes) {
        md += `${"#".repeat(Math.min(level, 6))} ${node.title}\n`;
        if (node.description) md += `${node.description}\n`;
        md += `\n`;
        if (node.children?.length) md += toMarkdown(node.children, level + 1);
      }
      return md;
    }

    function exportMD() {
      if (!CURRENT_TOC.length) return;
      const topic = $("inpTopic").value.trim() || "topic";
      const md = `# Table of Contents — ${topic}\n\n` + toMarkdown(CURRENT_TOC, 2);
      blobDownload(`toc-${slug(topic)}.md`, md, "text/markdown");
    }

    // ----------------------- Hooks -----------------------
    $("inpTemp").addEventListener("input", (e) => $("tempVal").textContent = Number(e.target.value).toFixed(2));
    $("btnGen").addEventListener("click", generate);
    $("btnCopyJSON").addEventListener("click", copyJSON);
    $("btnExportJSON").addEventListener("click", exportJSON);
    $("btnExportMD").addEventListener("click", exportMD);
    $("btnUseMock").addEventListener("click", () => { LIVE = false; $("statusText").textContent = "Mock"; });
    $("btnUseLive").addEventListener("click", () => { LIVE = true; $("statusText").textContent = "Live"; });
  </script>
</body>
</html>
